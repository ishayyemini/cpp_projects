<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/hw_3/simulator/Simulator.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hw_3/simulator/Simulator.cpp" />
              <option name="originalContent" value="#include &quot;Simulator.h&quot;&#10;&#10;#include &lt;algorithm&gt;&#10;#include &lt;chrono&gt;&#10;#include &lt;cctype&gt;&#10;#include &lt;filesystem&gt;&#10;#include &lt;fstream&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;mutex&gt;&#10;#include &lt;optional&gt;&#10;#include &lt;queue&gt;&#10;#include &lt;set&gt;&#10;#include &lt;sstream&gt;&#10;#include &lt;thread&gt;&#10;#include &lt;utility&gt;&#10;&#10;#include &lt;dlfcn.h&gt;&#10;&#10;namespace fs = std::filesystem;&#10;&#10;// -------------------- Utils --------------------&#10;static inline std::string trim(const std::string &amp;s) {&#10;    size_t i = 0, j = s.size();&#10;    while (i &lt; j &amp;&amp; std::isspace((unsigned char) s[i])) ++i;&#10;    while (j &gt; i &amp;&amp; std::isspace((unsigned char) s[j - 1])) --j;&#10;    return s.substr(i, j - i);&#10;}&#10;&#10;std::string Simulator::basenameNoExt(const std::string &amp;path) {&#10;    fs::path p(path);&#10;    return p.stem().string();&#10;}&#10;&#10;std::string Simulator::epochTimeId() {&#10;    using namespace std::chrono;&#10;    auto now = time_point_cast&lt;microseconds&gt;(system_clock::now()).time_since_epoch().count();&#10;    return std::to_string(now);&#10;}&#10;&#10;bool Simulator::writeTextFile(const std::string &amp;path, const std::string &amp;content, std::string &amp;err) {&#10;    try {&#10;        std::ofstream out(path);&#10;        if (!out) {&#10;            err = &quot;Cannot open file for writing: &quot; + path;&#10;            return false;&#10;        }&#10;        out &lt;&lt; content;&#10;        if (!out.good()) {&#10;            err = &quot;Write failed: &quot; + path;&#10;            return false;&#10;        }&#10;        return true;&#10;    } catch (const std::exception &amp;e) {&#10;        err = e.what();&#10;        return false;&#10;    }&#10;}&#10;&#10;std::string Simulator::joinPath(const std::string &amp;a, const std::string &amp;b) {&#10;    return (fs::path(a) / fs::path(b)).string();&#10;}&#10;&#10;// -------------------- Filesystem --------------------&#10;bool Simulator::fileExistsReadable(const std::string &amp;path) {&#10;    std::error_code ec;&#10;    return fs::exists(path, ec) &amp;&amp; fs::is_regular_file(path, ec);&#10;}&#10;&#10;bool Simulator::dirExistsListable(const std::string &amp;path) {&#10;    std::error_code ec;&#10;    return fs::exists(path, ec) &amp;&amp; fs::is_directory(path, ec);&#10;}&#10;&#10;std::vector&lt;std::string&gt; Simulator::listRegularFiles(const std::string &amp;dir) {&#10;    std::vector&lt;std::string&gt; out;&#10;    std::error_code ec;&#10;    for (auto &amp;de: fs::directory_iterator(dir, ec)) {&#10;        if (ec) break;&#10;        if (de.is_regular_file()) out.push_back(de.path().string());&#10;    }&#10;    std::sort(out.begin(), out.end());&#10;    return out;&#10;}&#10;&#10;std::vector&lt;std::string&gt; Simulator::listFilesWithExtension(const std::string &amp;dir, const std::string &amp;ext) {&#10;    std::vector&lt;std::string&gt; out;&#10;    std::error_code ec;&#10;    for (auto &amp;de: fs::directory_iterator(dir, ec)) {&#10;        if (ec) break;&#10;        if (de.is_regular_file() &amp;&amp; de.path().extension() == ext) out.push_back(de.path().string());&#10;    }&#10;    std::sort(out.begin(), out.end());&#10;    return out;&#10;}&#10;&#10;// -------------------- Dynamic loading helpers --------------------&#10;void *Simulator::dlopenOrNull(const std::string &amp;path) {&#10;    void *h = dlopen(path.c_str(), RTLD_LAZY | RTLD_GLOBAL);&#10;    if (!h) {&#10;        std::cerr &lt;&lt; &quot;Failed to load library '&quot; &lt;&lt; path &lt;&lt; &quot;': &quot; &lt;&lt; dlerror() &lt;&lt; &quot;\n&quot;;&#10;        return nullptr;&#10;    }&#10;    return h;&#10;}&#10;&#10;void Simulator::dlcloseAll(std::vector&lt;void *&gt; &amp;handles) {&#10;    for (void *h: handles) if (h) dlclose(h);&#10;    handles.clear();&#10;}&#10;&#10;// -------------------- ThreadPool --------------------&#10;struct Simulator::ThreadPool::Impl {&#10;    std::vector&lt;std::thread&gt; workers;&#10;    std::queue&lt;std::function&lt;void()&gt; &gt; q;&#10;    std::mutex m;&#10;    std::condition_variable cv;&#10;    bool stop = false;&#10;    size_t active = 0;&#10;};&#10;&#10;Simulator::ThreadPool::ThreadPool(size_t nThreads) : impl_(std::make_unique&lt;Impl&gt;()) {&#10;    impl_-&gt;workers.reserve(nThreads);&#10;    for (size_t i = 0; i &lt; nThreads; i++) {&#10;        impl_-&gt;workers.emplace_back([this] {&#10;            for (;;) {&#10;                std::function&lt;void()&gt; task; {&#10;                    std::unique_lock&lt;std::mutex&gt; lk(impl_-&gt;m);&#10;                    impl_-&gt;cv.wait(lk, [this] { return impl_-&gt;stop || !impl_-&gt;q.empty(); });&#10;                    if (impl_-&gt;stop &amp;&amp; impl_-&gt;q.empty()) return;&#10;                    task = std::move(impl_-&gt;q.front());&#10;                    impl_-&gt;q.pop();&#10;                    impl_-&gt;active++;&#10;                }&#10;                try { task(); } catch (...) {&#10;                } {&#10;                    std::lock_guard&lt;std::mutex&gt; lk(impl_-&gt;m);&#10;                    impl_-&gt;active--;&#10;                }&#10;                impl_-&gt;cv.notify_all();&#10;            }&#10;        });&#10;    }&#10;}&#10;&#10;Simulator::ThreadPool::~ThreadPool() { {&#10;        std::lock_guard&lt;std::mutex&gt; lk(impl_-&gt;m);&#10;        impl_-&gt;stop = true;&#10;    }&#10;    impl_-&gt;cv.notify_all();&#10;    for (auto &amp;t: impl_-&gt;workers) if (t.joinable()) t.join();&#10;}&#10;&#10;void Simulator::ThreadPool::enqueue(std::function&lt;void()&gt; task) { {&#10;        std::lock_guard&lt;std::mutex&gt; lk(impl_-&gt;m);&#10;        impl_-&gt;q.push(std::move(task));&#10;    }&#10;    impl_-&gt;cv.notify_one();&#10;}&#10;&#10;void Simulator::ThreadPool::waitIdle() {&#10;    std::unique_lock&lt;std::mutex&gt; lk(impl_-&gt;m);&#10;    impl_-&gt;cv.wait(lk, [this] { return impl_-&gt;q.empty() &amp;&amp; impl_-&gt;active == 0; });&#10;}&#10;&#10;// -------------------- Args parsing &amp; usage --------------------&#10;static bool parseKV(const std::string &amp;s, std::string &amp;key, std::string &amp;val) {&#10;    auto pos = s.find('=');&#10;    if (pos == std::string::npos) return false;&#10;    std::string lhs = s.substr(0, pos);&#10;    std::string rhs = s.substr(pos + 1);&#10;    key = trim(lhs);&#10;    val = trim(rhs);&#10;    return !(key.empty() || val.empty());&#10;}&#10;&#10;std::string Simulator::usageComparative() {&#10;    return&#10;            &quot;Usage: ./simulator_&lt;ids&gt; -comparative game_map=&lt;file&gt; game_managers_folder=&lt;folder&gt; algorithm1=&lt;file&gt; algorithm2=&lt;file&gt; [num_threads=&lt;num&gt;] [-verbose]\n&quot;;&#10;}&#10;&#10;std::string Simulator::usageCompetition() {&#10;    return&#10;            &quot;Usage: ./simulator_&lt;ids&gt; -competition game_maps_folder=&lt;folder&gt; game_manager=&lt;file&gt; algorithms_folder=&lt;folder&gt; [num_threads=&lt;num&gt;] [-verbose]\n&quot;;&#10;}&#10;&#10;std::optional&lt;Args&gt; Simulator::parseArgs(int argc, char **argv, std::string &amp;usageOrError) {&#10;    if (argc &lt; 2) {&#10;        usageOrError = usageComparative() + usageCompetition();&#10;        return std::nullopt;&#10;    }&#10;&#10;    Args args{};&#10;    bool modeSet = false;&#10;    std::unordered_set&lt;std::string&gt; supported = {&#10;        &quot;-comparative&quot;, &quot;-competition&quot;, &quot;-verbose&quot;,&#10;        &quot;game_map&quot;, &quot;game_managers_folder&quot;, &quot;algorithm1&quot;, &quot;algorithm2&quot;,&#10;        &quot;game_maps_folder&quot;, &quot;game_manager&quot;, &quot;algorithms_folder&quot;,&#10;        &quot;num_threads&quot;&#10;    };&#10;    std::vector&lt;std::string&gt; unknown;&#10;&#10;    for (int i = 1; i &lt; argc; i++) {&#10;        std::string a = argv[i];&#10;        if (a == &quot;-comparative&quot;) {&#10;            if (modeSet &amp;&amp; args.mode != Args::Mode::Comparative) {&#10;                usageOrError = &quot;Error: Both -comparative and -competition provided.\n&quot; + usageComparative() +&#10;                               usageCompetition();&#10;                return std::nullopt;&#10;            }&#10;            args.mode = Args::Mode::Comparative;&#10;            modeSet = true;&#10;        } else if (a == &quot;-competition&quot;) {&#10;            if (modeSet &amp;&amp; args.mode != Args::Mode::Competition) {&#10;                usageOrError = &quot;Error: Both -comparative and -competition provided.\n&quot; + usageComparative() +&#10;                               usageCompetition();&#10;                return std::nullopt;&#10;            }&#10;            args.mode = Args::Mode::Competition;&#10;            modeSet = true;&#10;        } else if (a == &quot;-verbose&quot;) {&#10;            args.verbose = true;&#10;        } else {&#10;            std::string k, v;&#10;            if (!parseKV(a, k, v)) {&#10;                unknown.push_back(a);&#10;                continue;&#10;            }&#10;            if (!supported.count(k)) {&#10;                unknown.push_back(a);&#10;                continue;&#10;            }&#10;            if (k == &quot;game_map&quot;) args.gameMapFile = v;&#10;            else if (k == &quot;game_managers_folder&quot;) args.gameManagersFolder = v;&#10;            else if (k == &quot;algorithm1&quot;) args.algorithm1File = v;&#10;            else if (k == &quot;algorithm2&quot;) args.algorithm2File = v;&#10;            else if (k == &quot;game_maps_folder&quot;) args.gameMapsFolder = v;&#10;            else if (k == &quot;game_manager&quot;) args.gameManagerFile = v;&#10;            else if (k == &quot;algorithms_folder&quot;) args.algorithmsFolder = v;&#10;            else if (k == &quot;num_threads&quot;) {&#10;                try { args.numThreads = std::max(1, std::stoi(v)); } catch (...) { args.numThreads = 1; }&#10;                // numThreads is number of worker threads in addition to main.&#10;                if (args.numThreads == 2) args.numThreads = 2;&#10;                // total threads != 2 already satisfied (main + 2 workers = 3)&#10;            }&#10;        }&#10;    }&#10;&#10;    if (!unknown.empty()) {&#10;        std::ostringstream oss;&#10;        oss &lt;&lt; &quot;Error: Unsupported arguments: &quot;;&#10;        for (size_t i = 0; i &lt; unknown.size(); ++i) {&#10;            if (i) oss &lt;&lt; &quot;, &quot;;&#10;            oss &lt;&lt; &quot;'&quot; &lt;&lt; unknown[i] &lt;&lt; &quot;'&quot;;&#10;        }&#10;        oss &lt;&lt; &quot;\n&quot; &lt;&lt; usageComparative() &lt;&lt; usageCompetition();&#10;        usageOrError = oss.str();&#10;        return std::nullopt;&#10;    }&#10;&#10;    if (!modeSet) {&#10;        usageOrError = &quot;Error: Missing mode (-comparative or -competition)\n&quot; + usageComparative() + usageCompetition();&#10;        return std::nullopt;&#10;    }&#10;&#10;    if (args.mode == Args::Mode::Comparative) {&#10;        std::vector&lt;std::string&gt; missing;&#10;        if (args.gameMapFile.empty()) missing.push_back(&quot;game_map&quot;);&#10;        if (args.gameManagersFolder.empty()) missing.push_back(&quot;game_managers_folder&quot;);&#10;        if (args.algorithm1File.empty()) missing.push_back(&quot;algorithm1&quot;);&#10;        if (args.algorithm2File.empty()) missing.push_back(&quot;algorithm2&quot;);&#10;        if (!missing.empty()) {&#10;            std::ostringstream oss;&#10;            oss &lt;&lt; &quot;Error: Missing required arguments: &quot;;&#10;            for (size_t i = 0; i &lt; missing.size(); ++i) {&#10;                if (i) oss &lt;&lt; &quot;, &quot;;&#10;                oss &lt;&lt; missing[i];&#10;            }&#10;            oss &lt;&lt; &quot;\n&quot; &lt;&lt; usageComparative();&#10;            usageOrError = oss.str();&#10;            return std::nullopt;&#10;        }&#10;        if (!fileExistsReadable(args.gameMapFile)) {&#10;            usageOrError = &quot;Error: game_map file cannot be opened: &quot; + args.gameMapFile + &quot;\n&quot; + usageComparative();&#10;            return std::nullopt;&#10;        }&#10;        if (!dirExistsListable(args.gameManagersFolder)) {&#10;            usageOrError = &quot;Error: game_managers_folder cannot be traversed: &quot; + args.gameManagersFolder + &quot;\n&quot; +&#10;                           usageComparative();&#10;            return std::nullopt;&#10;        }&#10;        if (!fileExistsReadable(args.algorithm1File)) {&#10;            usageOrError = &quot;Error: algorithm1 file cannot be opened: &quot; + args.algorithm1File + &quot;\n&quot; +&#10;                           usageComparative();&#10;            return std::nullopt;&#10;        }&#10;        if (!fileExistsReadable(args.algorithm2File)) {&#10;            usageOrError = &quot;Error: algorithm2 file cannot be opened: &quot; + args.algorithm2File + &quot;\n&quot; +&#10;                           usageComparative();&#10;            return std::nullopt;&#10;        }&#10;        auto gms = listFilesWithExtension(args.gameManagersFolder, &quot;.so&quot;);&#10;        if (gms.empty()) {&#10;            usageOrError = &quot;Error: game_managers_folder has no .so files: &quot; + args.gameManagersFolder + &quot;\n&quot; +&#10;                           usageComparative();&#10;            return std::nullopt;&#10;        }&#10;    } else {&#10;        // Competition&#10;        std::vector&lt;std::string&gt; missing;&#10;        if (args.gameMapsFolder.empty()) missing.push_back(&quot;game_maps_folder&quot;);&#10;        if (args.gameManagerFile.empty()) missing.push_back(&quot;game_manager&quot;);&#10;        if (args.algorithmsFolder.empty()) missing.push_back(&quot;algorithms_folder&quot;);&#10;        if (!missing.empty()) {&#10;            std::ostringstream oss;&#10;            oss &lt;&lt; &quot;Error: Missing required arguments: &quot;;&#10;            for (size_t i = 0; i &lt; missing.size(); ++i) {&#10;                if (i) oss &lt;&lt; &quot;, &quot;;&#10;                oss &lt;&lt; missing[i];&#10;            }&#10;            oss &lt;&lt; &quot;\n&quot; &lt;&lt; usageCompetition();&#10;            usageOrError = oss.str();&#10;            return std::nullopt;&#10;        }&#10;        if (!dirExistsListable(args.gameMapsFolder)) {&#10;            usageOrError = &quot;Error: game_maps_folder cannot be traversed: &quot; + args.gameMapsFolder + &quot;\n&quot; +&#10;                           usageCompetition();&#10;            return std::nullopt;&#10;        }&#10;        if (!fileExistsReadable(args.gameManagerFile)) {&#10;            usageOrError = &quot;Error: game_manager file cannot be opened: &quot; + args.gameManagerFile + &quot;\n&quot; +&#10;                           usageCompetition();&#10;            return std::nullopt;&#10;        }&#10;        if (!dirExistsListable(args.algorithmsFolder)) {&#10;            usageOrError = &quot;Error: algorithms_folder cannot be traversed: &quot; + args.algorithmsFolder + &quot;\n&quot; +&#10;                           usageCompetition();&#10;            return std::nullopt;&#10;        }&#10;        auto maps = listRegularFiles(args.gameMapsFolder);&#10;        if (maps.empty()) {&#10;            usageOrError = &quot;Error: game_maps_folder has no map files\n&quot; + usageCompetition();&#10;            return std::nullopt;&#10;        }&#10;        auto algs = listFilesWithExtension(args.algorithmsFolder, &quot;.so&quot;);&#10;        if (algs.size() &lt; 2) {&#10;            usageOrError = &quot;Error: algorithms_folder has fewer than 2 algorithms (.so files)\n&quot; + usageCompetition();&#10;            return std::nullopt;&#10;        }&#10;    }&#10;&#10;    return args;&#10;}&#10;&#10;// -------------------- Registrar loading --------------------&#10;std::optional&lt;Simulator::AlgWrap&gt; Simulator::loadAlgorithmSo(const std::string &amp;soPath) {&#10;    auto &amp;reg = AlgorithmRegistrar::getAlgorithmRegistrar();&#10;    const std::string name = basenameNoExt(soPath);&#10;    size_t before = reg.count();&#10;&#10;    reg.createAlgorithmFactoryEntry(name);&#10;    void *h = dlopenOrNull(soPath);&#10;    if (!h) {&#10;        reg.removeLast();&#10;        return std::nullopt;&#10;    }&#10;&#10;    try {&#10;        reg.validateLastRegistration();&#10;    } catch (const AlgorithmRegistrar::BadRegistrationException &amp;e) {&#10;        std::cerr &lt;&lt; &quot;Algorithm registration failed for '&quot; &lt;&lt; name &lt;&lt; &quot;':&quot;&#10;                &lt;&lt; &quot; hasName=&quot; &lt;&lt; e.hasName&#10;                &lt;&lt; &quot; hasPlayerFactory=&quot; &lt;&lt; e.hasPlayerFactory&#10;                &lt;&lt; &quot; hasTankAlgorithmFactory=&quot; &lt;&lt; e.hasTankAlgorithmFactory&#10;                &lt;&lt; &quot;\n&quot;;&#10;        reg.removeLast();&#10;        dlclose(h);&#10;        return std::nullopt;&#10;    }&#10;&#10;    // Build a stable wrapper capturing the registrar index (not a reference!)&#10;    AlgWrap wrap;&#10;    wrap.name = name;&#10;    wrap.makePlayer = [entryIndex = before](int player_index, size_t x, size_t y, size_t max_steps,&#10;                                            size_t num_shells) -&gt; std::unique_ptr&lt;Player&gt; {&#10;        auto &amp;reg2 = AlgorithmRegistrar::getAlgorithmRegistrar();&#10;        size_t idx = 0;&#10;        for (const auto &amp;alg: reg2) {&#10;            if (idx++ == entryIndex) {&#10;                return alg.createPlayer(player_index, x, y, max_steps, num_shells);&#10;            }&#10;        }&#10;        return nullptr;&#10;    };&#10;&#10;    // Copy the tank algorithm factory by value (safe)&#10;    size_t idx = 0;&#10;    for (const auto &amp;alg: reg) {&#10;        if (idx++ == before) {&#10;            wrap.tankFactory = alg.getTankAlgorithmFactory();&#10;            break;&#10;        }&#10;    }&#10;    return wrap;&#10;}&#10;&#10;std::pair&lt;std::vector&lt;Simulator::AlgWrap&gt;, std::vector&lt;void *&gt; &gt; Simulator::loadAlgorithmFolder(&#10;    const std::string &amp;folder) {&#10;    std::vector&lt;AlgWrap&gt; out;&#10;    std::vector&lt;void *&gt; handles;&#10;    auto sos = listFilesWithExtension(folder, &quot;.so&quot;);&#10;    auto &amp;reg = AlgorithmRegistrar::getAlgorithmRegistrar();&#10;    for (auto &amp;so: sos) {&#10;        const std::string name = basenameNoExt(so);&#10;        size_t before = reg.count();&#10;        reg.createAlgorithmFactoryEntry(name);&#10;        void *h = dlopenOrNull(so);&#10;        if (!h) {&#10;            reg.removeLast();&#10;            continue;&#10;        }&#10;        try {&#10;            reg.validateLastRegistration();&#10;        } catch (const AlgorithmRegistrar::BadRegistrationException &amp;) {&#10;            std::cerr &lt;&lt; &quot;Algorithm registration failed for '&quot; &lt;&lt; name &lt;&lt; &quot;'.\n&quot;;&#10;            reg.removeLast();&#10;            dlclose(h);&#10;            continue;&#10;        }&#10;        handles.push_back(h);&#10;&#10;        // Build wrapper capturing index&#10;        AlgWrap wrap;&#10;        wrap.name = name;&#10;        wrap.makePlayer = [entryIndex = before](int player_index, size_t x, size_t y, size_t max_steps,&#10;                                                size_t num_shells) -&gt; std::unique_ptr&lt;Player&gt; {&#10;            auto &amp;reg2 = AlgorithmRegistrar::getAlgorithmRegistrar();&#10;            size_t idx = 0;&#10;            for (const auto &amp;alg: reg2) {&#10;                if (idx++ == entryIndex) {&#10;                    return alg.createPlayer(player_index, x, y, max_steps, num_shells);&#10;                }&#10;            }&#10;            return nullptr;&#10;        };&#10;        size_t idx = 0;&#10;        for (const auto &amp;alg: reg) {&#10;            if (idx++ == before) {&#10;                wrap.tankFactory = alg.getTankAlgorithmFactory();&#10;                break;&#10;            }&#10;        }&#10;        out.emplace_back(std::move(wrap));&#10;    }&#10;    return {out, handles};&#10;}&#10;&#10;std::optional&lt;Simulator::GmWrap&gt; Simulator::loadGameManagerSo(const std::string &amp;soPath, bool verbose) {&#10;    auto &amp;reg = GameManagerRegistrar::getGameManagerRegistrar();&#10;    const std::string name = basenameNoExt(soPath);&#10;    size_t before = reg.count();&#10;&#10;    reg.createGameManagerFactoryEntry(name);&#10;    void *h = dlopenOrNull(soPath);&#10;    if (!h) {&#10;        reg.removeLast();&#10;        return std::nullopt;&#10;    }&#10;&#10;    try {&#10;        reg.validateLastRegistration();&#10;    } catch (const GameManagerRegistrar::BadRegistrationException &amp;) {&#10;        std::cerr &lt;&lt; &quot;GameManager registration failed for '&quot; &lt;&lt; name &lt;&lt; &quot;'.\n&quot;;&#10;        reg.removeLast();&#10;        dlclose(h);&#10;        return std::nullopt;&#10;    }&#10;&#10;    GmWrap wrap;&#10;    wrap.name = name;&#10;    wrap.makeGameManager = [entryIndex = before, verbose]() -&gt; std::unique_ptr&lt;AbstractGameManager&gt; {&#10;        auto &amp;reg2 = GameManagerRegistrar::getGameManagerRegistrar();&#10;        size_t idx = 0;&#10;        for (const auto &amp;gm: reg2) {&#10;            if (idx++ == entryIndex) {&#10;                return gm.createGameManager(verbose);&#10;            }&#10;        }&#10;        return nullptr;&#10;    };&#10;    return wrap;&#10;}&#10;&#10;std::pair&lt;std::vector&lt;Simulator::GmWrap&gt;, std::vector&lt;void *&gt; &gt; Simulator::loadGameManagersFolder(&#10;    const std::string &amp;folder, bool verbose) {&#10;    std::vector&lt;GmWrap&gt; out;&#10;    std::vector&lt;void *&gt; handles;&#10;    auto sos = listFilesWithExtension(folder, &quot;.so&quot;);&#10;    auto &amp;reg = GameManagerRegistrar::getGameManagerRegistrar();&#10;    for (auto &amp;so: sos) {&#10;        const std::string name = basenameNoExt(so);&#10;        size_t before = reg.count();&#10;        reg.createGameManagerFactoryEntry(name);&#10;        void *h = dlopenOrNull(so);&#10;        if (!h) {&#10;            reg.removeLast();&#10;            continue;&#10;        }&#10;        try {&#10;            reg.validateLastRegistration();&#10;        } catch (const GameManagerRegistrar::BadRegistrationException &amp;) {&#10;            std::cerr &lt;&lt; &quot;GameManager registration failed for '&quot; &lt;&lt; name &lt;&lt; &quot;'.\n&quot;;&#10;            reg.removeLast();&#10;            dlclose(h);&#10;            continue;&#10;        }&#10;        handles.push_back(h);&#10;&#10;        GmWrap wrap;&#10;        wrap.name = name;&#10;        wrap.makeGameManager = [entryIndex = before, verbose]() -&gt; std::unique_ptr&lt;AbstractGameManager&gt; {&#10;            auto &amp;reg2 = GameManagerRegistrar::getGameManagerRegistrar();&#10;            size_t idx = 0;&#10;            for (const auto &amp;gm: reg2) {&#10;                if (idx++ == entryIndex) {&#10;                    return gm.createGameManager(verbose);&#10;                }&#10;            }&#10;            return nullptr;&#10;        };&#10;        out.emplace_back(std::move(wrap));&#10;    }&#10;    return {out, handles};&#10;}&#10;&#10;// -------------------- Pairing --------------------&#10;std::vector&lt;std::pair&lt;size_t, size_t&gt; &gt; Simulator::computePairsForK(size_t N, size_t k, bool dedupUnordered) {&#10;    std::vector&lt;std::pair&lt;size_t, size_t&gt; &gt; pairs;&#10;    pairs.reserve(N);&#10;    std::unordered_set&lt;uint64_t&gt; seen;&#10;    auto key = [](size_t a, size_t b)-&gt; uint64_t {&#10;        if (a &gt; b) std::swap(a, b);&#10;        return (uint64_t(a) &lt;&lt; 32) | uint64_t(b);&#10;    };&#10;    for (size_t i = 0; i &lt; N; i++) {&#10;        size_t j = (i + 1 + (k % (N - 1))) % N;&#10;        if (dedupUnordered) {&#10;            uint64_t kk = key(i, j);&#10;            if (seen.count(kk)) continue;&#10;            seen.insert(kk);&#10;        }&#10;        pairs.emplace_back(i, j);&#10;    }&#10;    return pairs;&#10;}&#10;&#10;// -------------------- Comparative key hashing --------------------&#10;size_t Simulator::ComparativeKeyHash::operator()(const ComparativeKey &amp;k) const noexcept {&#10;    std::hash&lt;std::string&gt; hs;&#10;    size_t h = std::hash&lt;int&gt;()(k.winner) ^ std::hash&lt;int&gt;()(int(k.reason)) ^ std::hash&lt;size_t&gt;()(k.rounds);&#10;    for (auto &amp;line: k.finalMapDump) {&#10;        h ^= hs(line) + 0x9e3779b97f4a7c15ULL + (h &lt;&lt; 6) + (h &gt;&gt; 2);&#10;    }&#10;    return h;&#10;}&#10;&#10;bool Simulator::ComparativeKeyEq::operator()(const ComparativeKey &amp;a, const ComparativeKey &amp;b) const noexcept {&#10;    return a.winner == b.winner &amp;&amp; a.reason == b.reason &amp;&amp; a.rounds == b.rounds &amp;&amp; a.finalMapDump == b.finalMapDump;&#10;}&#10;&#10;// -------------------- Output formatting --------------------&#10;static std::string reasonToString(GameResult::Reason r) {&#10;    switch (r) {&#10;        case GameResult::ALL_TANKS_DEAD: return &quot;all tanks dead&quot;;&#10;        case GameResult::MAX_STEPS: return &quot;max steps&quot;;&#10;        case GameResult::ZERO_SHELLS: return &quot;zero shells&quot;;&#10;        default: return &quot;unknown&quot;;&#10;    }&#10;}&#10;&#10;static std::string resultMessage(int winner, GameResult::Reason reason) {&#10;    if (winner == 1) return &quot;Player 1 wins: &quot; + reasonToString(reason);&#10;    if (winner == 2) return &quot;Player 2 wins: &quot; + reasonToString(reason);&#10;    return &quot;Tie: &quot; + reasonToString(reason);&#10;}&#10;&#10;std::string Simulator::formatComparativeOutput(&#10;    const std::string &amp;gameMap,&#10;    const std::string &amp;alg1,&#10;    const std::string &amp;alg2,&#10;    const std::vector&lt;std::pair&lt;std::vector&lt;std::string&gt;, ComparativeKey&gt; &gt; &amp;grouped) {&#10;    std::ostringstream out;&#10;    out &lt;&lt; &quot;game_map=&quot; &lt;&lt; gameMap &lt;&lt; &quot;\n&quot;;&#10;    out &lt;&lt; &quot;algorithm1=&quot; &lt;&lt; alg1 &lt;&lt; &quot;\n&quot;;&#10;    out &lt;&lt; &quot;algorithm2=&quot; &lt;&lt; alg2 &lt;&lt; &quot;\n&quot;;&#10;    out &lt;&lt; &quot;\n&quot;;&#10;    bool firstGroup = true;&#10;    for (auto &amp;[gmNames, key]: grouped) {&#10;        if (!firstGroup) out &lt;&lt; &quot;\n&quot;;&#10;        firstGroup = false;&#10;        // 5th line: comma-separated GM names&#10;        for (size_t i = 0; i &lt; gmNames.size(); ++i) {&#10;            if (i) out &lt;&lt; &quot;, &quot;;&#10;            out &lt;&lt; gmNames[i];&#10;        }&#10;        out &lt;&lt; &quot;\n&quot;;&#10;        // 6th line: result message&#10;        out &lt;&lt; resultMessage(key.winner, key.reason) &lt;&lt; &quot;\n&quot;;&#10;        // 7th line: round number&#10;        out &lt;&lt; key.rounds &lt;&lt; &quot;\n&quot;;&#10;        // 8th line on: final map&#10;        for (auto &amp;line: key.finalMapDump) out &lt;&lt; line &lt;&lt; &quot;\n&quot;;&#10;    }&#10;    return out.str();&#10;}&#10;&#10;std::string Simulator::formatCompetitionOutput(&#10;    const std::string &amp;gameMapsFolder,&#10;    const std::string &amp;gameManagerSo,&#10;    const std::vector&lt;std::pair&lt;std::string, int&gt; &gt; &amp;scoresSorted) {&#10;    std::ostringstream out;&#10;    out &lt;&lt; &quot;game_maps_folder=&quot; &lt;&lt; gameMapsFolder &lt;&lt; &quot;\n&quot;;&#10;    out &lt;&lt; &quot;game_manager=&quot; &lt;&lt; gameManagerSo &lt;&lt; &quot;\n&quot;;&#10;    out &lt;&lt; &quot;\n&quot;;&#10;    for (auto &amp;[name, score]: scoresSorted) {&#10;        out &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; score &lt;&lt; &quot;\n&quot;;&#10;    }&#10;    return out.str();&#10;}&#10;&#10;// -------------------- Runners --------------------&#10;int Simulator::run(const Args &amp;args) {&#10;    try {&#10;        if (args.mode == Args::Mode::Comparative) return runComparative(args);&#10;        return runCompetition(args);&#10;    } catch (const std::exception &amp;e) {&#10;        std::cerr &lt;&lt; &quot;Fatal error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return 1;&#10;    }&#10;}&#10;&#10;int Simulator::runComparative(const Args &amp;args) {&#10;    // Prepare registrars&#10;    AlgorithmRegistrar::getAlgorithmRegistrar().clear();&#10;    GameManagerRegistrar::getGameManagerRegistrar().clear();&#10;&#10;    // Load algorithms&#10;    std::vector&lt;void *&gt; algHandles;&#10;    std::optional&lt;AlgWrap&gt; alg1 = loadAlgorithmSo(args.algorithm1File);&#10;    if (alg1) {&#10;        if (void *h = dlopenOrNull(args.algorithm1File)) algHandles.push_back(h);&#10;    }&#10;    std::optional&lt;AlgWrap&gt; alg2 = loadAlgorithmSo(args.algorithm2File);&#10;    if (alg2) {&#10;        if (void *h = dlopenOrNull(args.algorithm2File)) algHandles.push_back(h);&#10;    }&#10;    if (!alg1 || !alg2) {&#10;        std::cerr &lt;&lt; &quot;Error: failed to load algorithm(s).\n&quot; &lt;&lt; usageComparative();&#10;        dlcloseAll(algHandles);&#10;        return 1;&#10;    }&#10;&#10;    // Load game managers&#10;    auto [gms, gmHandles] = loadGameManagersFolder(args.gameManagersFolder, args.verbose);&#10;    if (gms.empty()) {&#10;        std::cerr &lt;&lt; &quot;Error: game_managers_folder has no valid .so game managers.\n&quot; &lt;&lt; usageComparative();&#10;        dlcloseAll(algHandles);&#10;        dlcloseAll(gmHandles);&#10;        return 1;&#10;    }&#10;&#10;    // Parse map using project InputParser (initializes Logger as needed)&#10;    Logger::getInstance().init(args.gameMapFile);&#10;    InputParser parser;&#10;    parser.parseInputFile(args.gameMapFile);&#10;    SatelliteView *mapView = parser.getSatelliteView();&#10;    if (!mapView) {&#10;        std::cerr &lt;&lt; &quot;Error: failed to parse game map: &quot; &lt;&lt; args.gameMapFile &lt;&lt; &quot;\n&quot; &lt;&lt; usageComparative();&#10;        dlcloseAll(algHandles);&#10;        dlcloseAll(gmHandles);&#10;        return 1;&#10;    }&#10;&#10;    const size_t width = parser.getWidth();&#10;    const size_t height = parser.getHeight();&#10;    const size_t maxSteps = parser.getMaxSteps();&#10;    const size_t numShells = parser.getNumShells();&#10;    const std::string mapName = parser.getBoardDescription();&#10;&#10;    struct OneRes {&#10;        std::string gmName;&#10;        ComparativeKey key;&#10;    };&#10;    std::mutex mtx;&#10;    std::vector&lt;OneRes&gt; results;&#10;&#10;    auto runOne = [&amp;](const GmWrap &amp;gw) {&#10;        auto gm = gw.makeGameManager();&#10;        if (!gm) return;&#10;&#10;        auto p1 = alg1-&gt;makePlayer(1, width, height, maxSteps, numShells);&#10;        auto p2 = alg2-&gt;makePlayer(2, width, height, maxSteps, numShells);&#10;        if (!p1 || !p2) return;&#10;&#10;        GameResult gr = gm-&gt;run(width, height, *mapView, mapName, maxSteps, numShells,&#10;                                *p1, alg1-&gt;name, *p2, alg2-&gt;name, alg1-&gt;tankFactory, alg2-&gt;tankFactory);&#10;&#10;        ComparativeKey key;&#10;        key.winner = gr.winner;&#10;        key.reason = gr.reason;&#10;        key.rounds = gr.rounds;&#10;&#10;        // Dump final game state&#10;        std::vector&lt;std::string&gt; dump;&#10;        dump.reserve(height);&#10;        SatelliteView *state = gr.gameState ? gr.gameState.get() : mapView;&#10;        for (size_t y = 0; y &lt; height; ++y) {&#10;            std::string row;&#10;            row.reserve(width);&#10;            for (size_t x = 0; x &lt; width; ++x) row.push_back(state-&gt;getObjectAt(x, y));&#10;            dump.push_back(std::move(row));&#10;        }&#10;        key.finalMapDump = std::move(dump);&#10;&#10;        std::lock_guard&lt;std::mutex&gt; lk(mtx);&#10;        results.push_back({gw.name, std::move(key)});&#10;    };&#10;&#10;    if (args.numThreads &lt;= 1) {&#10;        for (const auto &amp;gm: gms) runOne(gm);&#10;    } else {&#10;        ThreadPool pool(static_cast&lt;size_t&gt;(args.numThreads));&#10;        for (const auto &amp;gm: gms) pool.enqueue([&amp;, gm] { runOne(gm); });&#10;        pool.waitIdle();&#10;    }&#10;&#10;    if (results.empty()) {&#10;        std::cerr &lt;&lt; &quot;Error: no game managers produced results.\n&quot;;&#10;        dlcloseAll(algHandles);&#10;        dlcloseAll(gmHandles);&#10;        return 1;&#10;    }&#10;&#10;    // Group identical results&#10;    std::unordered_map&lt;ComparativeKey, std::vector&lt;std::string&gt;, ComparativeKeyHash, ComparativeKeyEq&gt; groups;&#10;    for (auto &amp;r: results) groups[r.key].push_back(r.gmName);&#10;&#10;    std::vector&lt;std::pair&lt;std::vector&lt;std::string&gt;, ComparativeKey&gt; &gt; grouped;&#10;    grouped.reserve(groups.size());&#10;    for (auto &amp;kv: groups) {&#10;        auto key = kv.first;&#10;        auto names = kv.second;&#10;        std::sort(names.begin(), names.end());&#10;        grouped.emplace_back(std::move(names), std::move(key));&#10;    }&#10;    std::sort(grouped.begin(), grouped.end(), [](const auto &amp;a, const auto &amp;b) {&#10;        return a.first.size() &gt; b.first.size();&#10;    });&#10;&#10;    // Emit output&#10;    const auto outPath = joinPath(args.gameManagersFolder, &quot;comparative_results_&quot; + epochTimeId() + &quot;.txt&quot;);&#10;    const auto content = formatComparativeOutput(args.gameMapFile, args.algorithm1File, args.algorithm2File,&#10;                                                 grouped);&#10;    std::string err;&#10;    if (!writeTextFile(outPath, content, err)) {&#10;        std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; err &lt;&lt; &quot;\n&quot;;&#10;        std::cout &lt;&lt; content;&#10;    }&#10;&#10;    dlcloseAll(algHandles);&#10;    dlcloseAll(gmHandles);&#10;    return 0;&#10;}&#10;&#10;int Simulator::runCompetition(const Args &amp;args) {&#10;    // Prepare registrars&#10;    AlgorithmRegistrar::getAlgorithmRegistrar().clear();&#10;    GameManagerRegistrar::getGameManagerRegistrar().clear();&#10;&#10;    // Load GM&#10;    auto gmOpt = loadGameManagerSo(args.gameManagerFile, args.verbose);&#10;    std::vector&lt;void *&gt; gmHandles;&#10;    if (!gmOpt) {&#10;        std::cerr &lt;&lt; &quot;Error: failed to load game_manager.\n&quot; &lt;&lt; usageCompetition();&#10;        dlcloseAll(gmHandles);&#10;        return 1;&#10;    }&#10;    if (void *h = dlopenOrNull(args.gameManagerFile)) gmHandles.push_back(h);&#10;&#10;    // Load algorithms&#10;    auto [algs, algHandles] = loadAlgorithmFolder(args.algorithmsFolder);&#10;    if (algs.size() &lt; 2) {&#10;        std::cerr &lt;&lt; &quot;Error: algorithms_folder has fewer than 2 valid .so files.\n&quot; &lt;&lt; usageCompetition();&#10;        dlcloseAll(algHandles);&#10;        dlcloseAll(gmHandles);&#10;        return 1;&#10;    }&#10;&#10;    // List maps&#10;    auto mapFiles = listRegularFiles(args.gameMapsFolder);&#10;    if (mapFiles.empty()) {&#10;        std::cerr &lt;&lt; &quot;Error: no map files in game_maps_folder.\n&quot; &lt;&lt; usageCompetition();&#10;        dlcloseAll(algHandles);&#10;        dlcloseAll(gmHandles);&#10;        return 1;&#10;    }&#10;&#10;    std::vector&lt;int&gt; scores(algs.size(), 0);&#10;    auto addWin = [&amp;](size_t idx) { scores[idx] += 3; };&#10;    auto addTie = [&amp;](size_t a, size_t b) {&#10;        scores[a] += 1;&#10;        scores[b] += 1;&#10;    };&#10;&#10;    std::mutex mtx;&#10;&#10;    auto runOne = [&amp;](const std::string &amp;mapPath, size_t ai, size_t aj) {&#10;        // Parse map&#10;        Logger::getInstance().init(mapPath);&#10;        InputParser parser;&#10;        parser.parseInputFile(mapPath);&#10;        SatelliteView *mapView = parser.getSatelliteView();&#10;        if (!mapView) return;&#10;&#10;        const size_t width = parser.getWidth();&#10;        const size_t height = parser.getHeight();&#10;        const size_t maxSteps = parser.getMaxSteps();&#10;        const size_t numShells = parser.getNumShells();&#10;        const std::string mapName = parser.getBoardDescription();&#10;&#10;        // Create GM instance&#10;        auto gm = gmOpt-&gt;makeGameManager();&#10;        if (!gm) return;&#10;&#10;        // Players&#10;        auto p1 = algs[ai].makePlayer(1, width, height, maxSteps, numShells);&#10;        auto p2 = algs[aj].makePlayer(2, width, height, maxSteps, numShells);&#10;        if (!p1 || !p2) return;&#10;&#10;        GameResult gr = gm-&gt;run(width, height, *mapView, mapName, maxSteps, numShells,&#10;                                *p1, algs[ai].name, *p2, algs[aj].name,&#10;                                algs[ai].tankFactory, algs[aj].tankFactory);&#10;&#10;        std::lock_guard&lt;std::mutex&gt; lk(mtx);&#10;        if (gr.winner == 1) addWin(ai);&#10;        else if (gr.winner == 2) addWin(aj);&#10;        else addTie(ai, aj);&#10;    };&#10;&#10;    bool usePool = args.numThreads &gt;= 2;&#10;    std::unique_ptr&lt;ThreadPool&gt; pool;&#10;    if (usePool) pool = std::make_unique&lt;ThreadPool&gt;(static_cast&lt;size_t&gt;(args.numThreads));&#10;&#10;    const size_t N = algs.size();&#10;    for (size_t k = 0; k &lt; mapFiles.size(); ++k) {&#10;        bool dedup = (N % 2 == 0) &amp;&amp; (k == (N / 2 - 1));&#10;        auto pairs = computePairsForK(N, k, dedup);&#10;        for (auto [i,j]: pairs) {&#10;            if (usePool) pool-&gt;enqueue([=] { runOne(mapFiles[k], i, j); });&#10;            else runOne(mapFiles[k], i, j);&#10;        }&#10;    }&#10;    if (usePool) pool-&gt;waitIdle();&#10;&#10;    // Build sorted scoreboard&#10;    std::vector&lt;std::pair&lt;std::string, int&gt; &gt; out;&#10;    out.reserve(algs.size());&#10;    for (size_t i = 0; i &lt; algs.size(); ++i) out.emplace_back(algs[i].name, scores[i]);&#10;    std::sort(out.begin(), out.end(), [](const auto &amp;a, const auto &amp;b) {&#10;        if (a.second != b.second) return a.second &gt; b.second;&#10;        return a.first &lt; b.first;&#10;    });&#10;&#10;    // Emit output&#10;    const auto content = formatCompetitionOutput(args.gameMapsFolder, args.gameManagerFile, out);&#10;    const auto outPath = joinPath(args.algorithmsFolder, &quot;competition_&quot; + epochTimeId() + &quot;.txt&quot;);&#10;    std::string err;&#10;    if (!writeTextFile(outPath, content, err)) {&#10;        std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; err &lt;&lt; &quot;\n&quot;;&#10;        std::cout &lt;&lt; content;&#10;    }&#10;&#10;    dlcloseAll(algHandles);&#10;    dlcloseAll(gmHandles);&#10;    return 0;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="#include &quot;Simulator.h&quot;&#10;&#10;#include &lt;algorithm&gt;&#10;#include &lt;chrono&gt;&#10;#include &lt;cctype&gt;&#10;#include &lt;filesystem&gt;&#10;#include &lt;fstream&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;mutex&gt;&#10;#include &lt;optional&gt;&#10;#include &lt;queue&gt;&#10;#include &lt;set&gt;&#10;#include &lt;sstream&gt;&#10;#include &lt;thread&gt;&#10;#include &lt;utility&gt;&#10;&#10;#include &lt;dlfcn.h&gt;&#10;&#10;namespace fs = std::filesystem;&#10;&#10;// -------------------- Utils --------------------&#10;static inline std::string trim(const std::string &amp;s) {&#10;    size_t i = 0, j = s.size();&#10;    while (i &lt; j &amp;&amp; std::isspace((unsigned char) s[i])) ++i;&#10;    while (j &gt; i &amp;&amp; std::isspace((unsigned char) s[j - 1])) --j;&#10;    return s.substr(i, j - i);&#10;}&#10;&#10;std::string Simulator::basenameNoExt(const std::string &amp;path) {&#10;    fs::path p(path);&#10;    return p.stem().string();&#10;}&#10;&#10;std::string Simulator::epochTimeId() {&#10;    using namespace std::chrono;&#10;    auto now = time_point_cast&lt;microseconds&gt;(system_clock::now()).time_since_epoch().count();&#10;    return std::to_string(now);&#10;}&#10;&#10;bool Simulator::writeTextFile(const std::string &amp;path, const std::string &amp;content, std::string &amp;err) {&#10;    try {&#10;        std::ofstream out(path);&#10;        if (!out) {&#10;            err = &quot;Cannot open file for writing: &quot; + path;&#10;            return false;&#10;        }&#10;        out &lt;&lt; content;&#10;        if (!out.good()) {&#10;            err = &quot;Write failed: &quot; + path;&#10;            return false;&#10;        }&#10;        return true;&#10;    } catch (const std::exception &amp;e) {&#10;        err = e.what();&#10;        return false;&#10;    }&#10;}&#10;&#10;std::string Simulator::joinPath(const std::string &amp;a, const std::string &amp;b) {&#10;    return (fs::path(a) / fs::path(b)).string();&#10;}&#10;&#10;// -------------------- Filesystem --------------------&#10;bool Simulator::fileExistsReadable(const std::string &amp;path) {&#10;    std::error_code ec;&#10;    return fs::exists(path, ec) &amp;&amp; fs::is_regular_file(path, ec);&#10;}&#10;&#10;bool Simulator::dirExistsListable(const std::string &amp;path) {&#10;    std::error_code ec;&#10;    return fs::exists(path, ec) &amp;&amp; fs::is_directory(path, ec);&#10;}&#10;&#10;std::vector&lt;std::string&gt; Simulator::listRegularFiles(const std::string &amp;dir) {&#10;    std::vector&lt;std::string&gt; out;&#10;    std::error_code ec;&#10;    for (auto &amp;de: fs::directory_iterator(dir, ec)) {&#10;        if (ec) break;&#10;        if (de.is_regular_file()) out.push_back(de.path().string());&#10;    }&#10;    std::sort(out.begin(), out.end());&#10;    return out;&#10;}&#10;&#10;std::vector&lt;std::string&gt; Simulator::listFilesWithExtension(const std::string &amp;dir, const std::string &amp;ext) {&#10;    std::vector&lt;std::string&gt; out;&#10;    std::error_code ec;&#10;    for (auto &amp;de: fs::directory_iterator(dir, ec)) {&#10;        if (ec) break;&#10;        if (de.is_regular_file() &amp;&amp; de.path().extension() == ext) out.push_back(de.path().string());&#10;    }&#10;    std::sort(out.begin(), out.end());&#10;    return out;&#10;}&#10;&#10;// -------------------- Dynamic loading helpers --------------------&#10;void *Simulator::dlopenOrNull(const std::string &amp;path) {&#10;    void *h = dlopen(path.c_str(), RTLD_LAZY | RTLD_GLOBAL);&#10;    if (!h) {&#10;        std::cerr &lt;&lt; &quot;Failed to load library '&quot; &lt;&lt; path &lt;&lt; &quot;': &quot; &lt;&lt; dlerror() &lt;&lt; &quot;\n&quot;;&#10;        return nullptr;&#10;    }&#10;    return h;&#10;}&#10;&#10;void Simulator::dlcloseAll(std::vector&lt;void *&gt; &amp;handles) {&#10;    for (void *h: handles) if (h) dlclose(h);&#10;    handles.clear();&#10;}&#10;&#10;// -------------------- ThreadPool --------------------&#10;struct Simulator::ThreadPool::Impl {&#10;    std::vector&lt;std::thread&gt; workers;&#10;    std::queue&lt;std::function&lt;void()&gt; &gt; q;&#10;    std::mutex m;&#10;    std::condition_variable cv;&#10;    bool stop = false;&#10;    size_t active = 0;&#10;};&#10;&#10;Simulator::ThreadPool::ThreadPool(size_t nThreads) : impl_(std::make_unique&lt;Impl&gt;()) {&#10;    impl_-&gt;workers.reserve(nThreads);&#10;    for (size_t i = 0; i &lt; nThreads; i++) {&#10;        impl_-&gt;workers.emplace_back([this] {&#10;            for (;;) {&#10;                std::function&lt;void()&gt; task; {&#10;                    std::unique_lock&lt;std::mutex&gt; lk(impl_-&gt;m);&#10;                    impl_-&gt;cv.wait(lk, [this] { return impl_-&gt;stop || !impl_-&gt;q.empty(); });&#10;                    if (impl_-&gt;stop &amp;&amp; impl_-&gt;q.empty()) return;&#10;                    task = std::move(impl_-&gt;q.front());&#10;                    impl_-&gt;q.pop();&#10;                    impl_-&gt;active++;&#10;                }&#10;                try { task(); } catch (...) {&#10;                } {&#10;                    std::lock_guard&lt;std::mutex&gt; lk(impl_-&gt;m);&#10;                    impl_-&gt;active--;&#10;                }&#10;                impl_-&gt;cv.notify_all();&#10;            }&#10;        });&#10;    }&#10;}&#10;&#10;Simulator::ThreadPool::~ThreadPool() { {&#10;        std::lock_guard&lt;std::mutex&gt; lk(impl_-&gt;m);&#10;        impl_-&gt;stop = true;&#10;    }&#10;    impl_-&gt;cv.notify_all();&#10;    for (auto &amp;t: impl_-&gt;workers) if (t.joinable()) t.join();&#10;}&#10;&#10;void Simulator::ThreadPool::enqueue(std::function&lt;void()&gt; task) { {&#10;        std::lock_guard&lt;std::mutex&gt; lk(impl_-&gt;m);&#10;        impl_-&gt;q.push(std::move(task));&#10;    }&#10;    impl_-&gt;cv.notify_one();&#10;}&#10;&#10;void Simulator::ThreadPool::waitIdle() {&#10;    std::unique_lock&lt;std::mutex&gt; lk(impl_-&gt;m);&#10;    impl_-&gt;cv.wait(lk, [this] { return impl_-&gt;q.empty() &amp;&amp; impl_-&gt;active == 0; });&#10;}&#10;&#10;// -------------------- Args parsing &amp; usage --------------------&#10;static bool parseKV(const std::string &amp;s, std::string &amp;key, std::string &amp;val) {&#10;    auto pos = s.find('=');&#10;    if (pos == std::string::npos) return false;&#10;    std::string lhs = s.substr(0, pos);&#10;    std::string rhs = s.substr(pos + 1);&#10;    key = trim(lhs);&#10;    val = trim(rhs);&#10;    return !(key.empty() || val.empty());&#10;}&#10;&#10;std::string Simulator::usageComparative() {&#10;    return&#10;            &quot;Usage: ./simulator_&lt;ids&gt; -comparative game_map=&lt;file&gt; game_managers_folder=&lt;folder&gt; algorithm1=&lt;file&gt; algorithm2=&lt;file&gt; [num_threads=&lt;num&gt;] [-verbose]\n&quot;;&#10;}&#10;&#10;std::string Simulator::usageCompetition() {&#10;    return&#10;            &quot;Usage: ./simulator_&lt;ids&gt; -competition game_maps_folder=&lt;folder&gt; game_manager=&lt;file&gt; algorithms_folder=&lt;folder&gt; [num_threads=&lt;num&gt;] [-verbose]\n&quot;;&#10;}&#10;&#10;std::optional&lt;Args&gt; Simulator::parseArgs(int argc, char **argv, std::string &amp;usageOrError) {&#10;    if (argc &lt; 2) {&#10;        usageOrError = usageComparative() + usageCompetition();&#10;        return std::nullopt;&#10;    }&#10;&#10;    Args args{};&#10;    bool modeSet = false;&#10;    std::unordered_set&lt;std::string&gt; supported = {&#10;        &quot;-comparative&quot;, &quot;-competition&quot;, &quot;-verbose&quot;,&#10;        &quot;game_map&quot;, &quot;game_managers_folder&quot;, &quot;algorithm1&quot;, &quot;algorithm2&quot;,&#10;        &quot;game_maps_folder&quot;, &quot;game_manager&quot;, &quot;algorithms_folder&quot;,&#10;        &quot;num_threads&quot;&#10;    };&#10;    std::vector&lt;std::string&gt; unknown;&#10;&#10;    for (int i = 1; i &lt; argc; i++) {&#10;        std::string a = argv[i];&#10;        if (a == &quot;-comparative&quot;) {&#10;            if (modeSet &amp;&amp; args.mode != Args::Mode::Comparative) {&#10;                usageOrError = &quot;Error: Both -comparative and -competition provided.\n&quot; + usageComparative() +&#10;                               usageCompetition();&#10;                return std::nullopt;&#10;            }&#10;            args.mode = Args::Mode::Comparative;&#10;            modeSet = true;&#10;        } else if (a == &quot;-competition&quot;) {&#10;            if (modeSet &amp;&amp; args.mode != Args::Mode::Competition) {&#10;                usageOrError = &quot;Error: Both -comparative and -competition provided.\n&quot; + usageComparative() +&#10;                               usageCompetition();&#10;                return std::nullopt;&#10;            }&#10;            args.mode = Args::Mode::Competition;&#10;            modeSet = true;&#10;        } else if (a == &quot;-verbose&quot;) {&#10;            args.verbose = true;&#10;        } else {&#10;            std::string k, v;&#10;            if (!parseKV(a, k, v)) {&#10;                unknown.push_back(a);&#10;                continue;&#10;            }&#10;            if (!supported.count(k)) {&#10;                unknown.push_back(a);&#10;                continue;&#10;            }&#10;            if (k == &quot;game_map&quot;) args.gameMapFile = v;&#10;            else if (k == &quot;game_managers_folder&quot;) args.gameManagersFolder = v;&#10;            else if (k == &quot;algorithm1&quot;) args.algorithm1File = v;&#10;            else if (k == &quot;algorithm2&quot;) args.algorithm2File = v;&#10;            else if (k == &quot;game_maps_folder&quot;) args.gameMapsFolder = v;&#10;            else if (k == &quot;game_manager&quot;) args.gameManagerFile = v;&#10;            else if (k == &quot;algorithms_folder&quot;) args.algorithmsFolder = v;&#10;            else if (k == &quot;num_threads&quot;) {&#10;                try { args.numThreads = std::max(1, std::stoi(v)); } catch (...) { args.numThreads = 1; }&#10;                // numThreads is number of worker threads in addition to main.&#10;                if (args.numThreads == 2) args.numThreads = 2;&#10;                // total threads != 2 already satisfied (main + 2 workers = 3)&#10;            }&#10;        }&#10;    }&#10;&#10;    if (!unknown.empty()) {&#10;        std::ostringstream oss;&#10;        oss &lt;&lt; &quot;Error: Unsupported arguments: &quot;;&#10;        for (size_t i = 0; i &lt; unknown.size(); ++i) {&#10;            if (i) oss &lt;&lt; &quot;, &quot;;&#10;            oss &lt;&lt; &quot;'&quot; &lt;&lt; unknown[i] &lt;&lt; &quot;'&quot;;&#10;        }&#10;        oss &lt;&lt; &quot;\n&quot; &lt;&lt; usageComparative() &lt;&lt; usageCompetition();&#10;        usageOrError = oss.str();&#10;        return std::nullopt;&#10;    }&#10;&#10;    if (!modeSet) {&#10;        usageOrError = &quot;Error: Missing mode (-comparative or -competition)\n&quot; + usageComparative() + usageCompetition();&#10;        return std::nullopt;&#10;    }&#10;&#10;    if (args.mode == Args::Mode::Comparative) {&#10;        std::vector&lt;std::string&gt; missing;&#10;        if (args.gameMapFile.empty()) missing.push_back(&quot;game_map&quot;);&#10;        if (args.gameManagersFolder.empty()) missing.push_back(&quot;game_managers_folder&quot;);&#10;        if (args.algorithm1File.empty()) missing.push_back(&quot;algorithm1&quot;);&#10;        if (args.algorithm2File.empty()) missing.push_back(&quot;algorithm2&quot;);&#10;        if (!missing.empty()) {&#10;            std::ostringstream oss;&#10;            oss &lt;&lt; &quot;Error: Missing required arguments: &quot;;&#10;            for (size_t i = 0; i &lt; missing.size(); ++i) {&#10;                if (i) oss &lt;&lt; &quot;, &quot;;&#10;                oss &lt;&lt; missing[i];&#10;            }&#10;            oss &lt;&lt; &quot;\n&quot; &lt;&lt; usageComparative();&#10;            usageOrError = oss.str();&#10;            return std::nullopt;&#10;        }&#10;        if (!fileExistsReadable(args.gameMapFile)) {&#10;            usageOrError = &quot;Error: game_map file cannot be opened: &quot; + args.gameMapFile + &quot;\n&quot; + usageComparative();&#10;            return std::nullopt;&#10;        }&#10;        if (!dirExistsListable(args.gameManagersFolder)) {&#10;            usageOrError = &quot;Error: game_managers_folder cannot be traversed: &quot; + args.gameManagersFolder + &quot;\n&quot; +&#10;                           usageComparative();&#10;            return std::nullopt;&#10;        }&#10;        if (!fileExistsReadable(args.algorithm1File)) {&#10;            usageOrError = &quot;Error: algorithm1 file cannot be opened: &quot; + args.algorithm1File + &quot;\n&quot; +&#10;                           usageComparative();&#10;            return std::nullopt;&#10;        }&#10;        if (!fileExistsReadable(args.algorithm2File)) {&#10;            usageOrError = &quot;Error: algorithm2 file cannot be opened: &quot; + args.algorithm2File + &quot;\n&quot; +&#10;                           usageComparative();&#10;            return std::nullopt;&#10;        }&#10;        auto gms = listFilesWithExtension(args.gameManagersFolder, &quot;.so&quot;);&#10;        if (gms.empty()) {&#10;            usageOrError = &quot;Error: game_managers_folder has no .so files: &quot; + args.gameManagersFolder + &quot;\n&quot; +&#10;                           usageComparative();&#10;            return std::nullopt;&#10;        }&#10;    } else {&#10;        // Competition&#10;        std::vector&lt;std::string&gt; missing;&#10;        if (args.gameMapsFolder.empty()) missing.push_back(&quot;game_maps_folder&quot;);&#10;        if (args.gameManagerFile.empty()) missing.push_back(&quot;game_manager&quot;);&#10;        if (args.algorithmsFolder.empty()) missing.push_back(&quot;algorithms_folder&quot;);&#10;        if (!missing.empty()) {&#10;            std::ostringstream oss;&#10;            oss &lt;&lt; &quot;Error: Missing required arguments: &quot;;&#10;            for (size_t i = 0; i &lt; missing.size(); ++i) {&#10;                if (i) oss &lt;&lt; &quot;, &quot;;&#10;                oss &lt;&lt; missing[i];&#10;            }&#10;            oss &lt;&lt; &quot;\n&quot; &lt;&lt; usageCompetition();&#10;            usageOrError = oss.str();&#10;            return std::nullopt;&#10;        }&#10;        if (!dirExistsListable(args.gameMapsFolder)) {&#10;            usageOrError = &quot;Error: game_maps_folder cannot be traversed: &quot; + args.gameMapsFolder + &quot;\n&quot; +&#10;                           usageCompetition();&#10;            return std::nullopt;&#10;        }&#10;        if (!fileExistsReadable(args.gameManagerFile)) {&#10;            usageOrError = &quot;Error: game_manager file cannot be opened: &quot; + args.gameManagerFile + &quot;\n&quot; +&#10;                           usageCompetition();&#10;            return std::nullopt;&#10;        }&#10;        if (!dirExistsListable(args.algorithmsFolder)) {&#10;            usageOrError = &quot;Error: algorithms_folder cannot be traversed: &quot; + args.algorithmsFolder + &quot;\n&quot; +&#10;                           usageCompetition();&#10;            return std::nullopt;&#10;        }&#10;        auto maps = listRegularFiles(args.gameMapsFolder);&#10;        if (maps.empty()) {&#10;            usageOrError = &quot;Error: game_maps_folder has no map files\n&quot; + usageCompetition();&#10;            return std::nullopt;&#10;        }&#10;        auto algs = listFilesWithExtension(args.algorithmsFolder, &quot;.so&quot;);&#10;        if (algs.size() &lt; 2) {&#10;            usageOrError = &quot;Error: algorithms_folder has fewer than 2 algorithms (.so files)\n&quot; + usageCompetition();&#10;            return std::nullopt;&#10;        }&#10;    }&#10;&#10;    return args;&#10;}&#10;&#10;// -------------------- Registrar loading --------------------&#10;std::optional&lt;Simulator::AlgWrap&gt; Simulator::loadAlgorithmSo(const std::string &amp;soPath) {&#10;    auto &amp;reg = AlgorithmRegistrar::getAlgorithmRegistrar();&#10;    const std::string name = basenameNoExt(soPath);&#10;    size_t before = reg.count();&#10;&#10;    reg.createAlgorithmFactoryEntry(name);&#10;    void *h = dlopenOrNull(soPath);&#10;    if (!h) {&#10;        reg.removeLast();&#10;        return std::nullopt;&#10;    }&#10;&#10;    try {&#10;        reg.validateLastRegistration();&#10;    } catch (const AlgorithmRegistrar::BadRegistrationException &amp;e) {&#10;        std::cerr &lt;&lt; &quot;Algorithm registration failed for '&quot; &lt;&lt; name &lt;&lt; &quot;':&quot;&#10;                &lt;&lt; &quot; hasName=&quot; &lt;&lt; e.hasName&#10;                &lt;&lt; &quot; hasPlayerFactory=&quot; &lt;&lt; e.hasPlayerFactory&#10;                &lt;&lt; &quot; hasTankAlgorithmFactory=&quot; &lt;&lt; e.hasTankAlgorithmFactory&#10;                &lt;&lt; &quot;\n&quot;;&#10;        reg.removeLast();&#10;        dlclose(h);&#10;        return std::nullopt;&#10;    }&#10;&#10;    // Build a stable wrapper capturing the registrar index (not a reference!)&#10;    AlgWrap wrap;&#10;    wrap.name = name;&#10;    wrap.makePlayer = [entryIndex = before](int player_index, size_t x, size_t y, size_t max_steps,&#10;                                            size_t num_shells) -&gt; std::unique_ptr&lt;Player&gt; {&#10;        auto &amp;reg2 = AlgorithmRegistrar::getAlgorithmRegistrar();&#10;        size_t idx = 0;&#10;        for (const auto &amp;alg: reg2) {&#10;            if (idx++ == entryIndex) {&#10;                return alg.createPlayer(player_index, x, y, max_steps, num_shells);&#10;            }&#10;        }&#10;        return nullptr;&#10;    };&#10;&#10;    // Copy the tank algorithm factory by value (safe)&#10;    size_t idx = 0;&#10;    for (const auto &amp;alg: reg) {&#10;        if (idx++ == before) {&#10;            wrap.tankFactory = alg.getTankAlgorithmFactory();&#10;            break;&#10;        }&#10;    }&#10;    return wrap;&#10;}&#10;&#10;std::pair&lt;std::vector&lt;Simulator::AlgWrap&gt;, std::vector&lt;void *&gt; &gt; Simulator::loadAlgorithmFolder(&#10;    const std::string &amp;folder) {&#10;    std::vector&lt;AlgWrap&gt; out;&#10;    std::vector&lt;void *&gt; handles;&#10;    auto sos = listFilesWithExtension(folder, &quot;.so&quot;);&#10;    auto &amp;reg = AlgorithmRegistrar::getAlgorithmRegistrar();&#10;    for (auto &amp;so: sos) {&#10;        const std::string name = basenameNoExt(so);&#10;        size_t before = reg.count();&#10;        reg.createAlgorithmFactoryEntry(name);&#10;        void *h = dlopenOrNull(so);&#10;        if (!h) {&#10;            reg.removeLast();&#10;            continue;&#10;        }&#10;        try {&#10;            reg.validateLastRegistration();&#10;        } catch (const AlgorithmRegistrar::BadRegistrationException &amp;) {&#10;            std::cerr &lt;&lt; &quot;Algorithm registration failed for '&quot; &lt;&lt; name &lt;&lt; &quot;'.\n&quot;;&#10;            reg.removeLast();&#10;            dlclose(h);&#10;            continue;&#10;        }&#10;        handles.push_back(h);&#10;&#10;        // Build wrapper capturing index&#10;        AlgWrap wrap;&#10;        wrap.name = name;&#10;        wrap.makePlayer = [entryIndex = before](int player_index, size_t x, size_t y, size_t max_steps,&#10;                                                size_t num_shells) -&gt; std::unique_ptr&lt;Player&gt; {&#10;            auto &amp;reg2 = AlgorithmRegistrar::getAlgorithmRegistrar();&#10;            size_t idx = 0;&#10;            for (const auto &amp;alg: reg2) {&#10;                if (idx++ == entryIndex) {&#10;                    return alg.createPlayer(player_index, x, y, max_steps, num_shells);&#10;                }&#10;            }&#10;            return nullptr;&#10;        };&#10;        size_t idx = 0;&#10;        for (const auto &amp;alg: reg) {&#10;            if (idx++ == before) {&#10;                wrap.tankFactory = alg.getTankAlgorithmFactory();&#10;                break;&#10;            }&#10;        }&#10;        out.emplace_back(std::move(wrap));&#10;    }&#10;    return {out, handles};&#10;}&#10;&#10;std::optional&lt;Simulator::GmWrap&gt; Simulator::loadGameManagerSo(const std::string &amp;soPath, bool verbose) {&#10;    auto &amp;reg = GameManagerRegistrar::getGameManagerRegistrar();&#10;    const std::string name = basenameNoExt(soPath);&#10;    size_t before = reg.count();&#10;&#10;    reg.createGameManagerFactoryEntry(name);&#10;    void *h = dlopenOrNull(soPath);&#10;    if (!h) {&#10;        reg.removeLast();&#10;        return std::nullopt;&#10;    }&#10;&#10;    try {&#10;        reg.validateLastRegistration();&#10;    } catch (const GameManagerRegistrar::BadRegistrationException &amp;) {&#10;        std::cerr &lt;&lt; &quot;GameManager registration failed for '&quot; &lt;&lt; name &lt;&lt; &quot;'.\n&quot;;&#10;        reg.removeLast();&#10;        dlclose(h);&#10;        return std::nullopt;&#10;    }&#10;&#10;    GmWrap wrap;&#10;    wrap.name = name;&#10;    wrap.makeGameManager = [entryIndex = before, verbose]() -&gt; std::unique_ptr&lt;AbstractGameManager&gt; {&#10;        auto &amp;reg2 = GameManagerRegistrar::getGameManagerRegistrar();&#10;        size_t idx = 0;&#10;        for (const auto &amp;gm: reg2) {&#10;            if (idx++ == entryIndex) {&#10;                return gm.createGameManager(verbose);&#10;            }&#10;        }&#10;        return nullptr;&#10;    };&#10;    return wrap;&#10;}&#10;&#10;std::pair&lt;std::vector&lt;Simulator::GmWrap&gt;, std::vector&lt;void *&gt; &gt; Simulator::loadGameManagersFolder(&#10;    const std::string &amp;folder, bool verbose) {&#10;    std::vector&lt;GmWrap&gt; out;&#10;    std::vector&lt;void *&gt; handles;&#10;    auto sos = listFilesWithExtension(folder, &quot;.so&quot;);&#10;    auto &amp;reg = GameManagerRegistrar::getGameManagerRegistrar();&#10;    for (auto &amp;so: sos) {&#10;        const std::string name = basenameNoExt(so);&#10;        size_t before = reg.count();&#10;        reg.createGameManagerFactoryEntry(name);&#10;        void *h = dlopenOrNull(so);&#10;        if (!h) {&#10;            reg.removeLast();&#10;            continue;&#10;        }&#10;        try {&#10;            reg.validateLastRegistration();&#10;        } catch (const GameManagerRegistrar::BadRegistrationException &amp;) {&#10;            std::cerr &lt;&lt; &quot;GameManager registration failed for '&quot; &lt;&lt; name &lt;&lt; &quot;'.\n&quot;;&#10;            reg.removeLast();&#10;            dlclose(h);&#10;            continue;&#10;        }&#10;        handles.push_back(h);&#10;&#10;        GmWrap wrap;&#10;        wrap.name = name;&#10;        wrap.makeGameManager = [entryIndex = before, verbose]() -&gt; std::unique_ptr&lt;AbstractGameManager&gt; {&#10;            auto &amp;reg2 = GameManagerRegistrar::getGameManagerRegistrar();&#10;            size_t idx = 0;&#10;            for (const auto &amp;gm: reg2) {&#10;                if (idx++ == entryIndex) {&#10;                    return gm.createGameManager(verbose);&#10;                }&#10;            }&#10;            return nullptr;&#10;        };&#10;        out.emplace_back(std::move(wrap));&#10;    }&#10;    return {out, handles};&#10;}&#10;&#10;// -------------------- Pairing --------------------&#10;std::vector&lt;std::pair&lt;size_t, size_t&gt; &gt; Simulator::computePairsForK(size_t N, size_t k, bool dedupUnordered) {&#10;    std::vector&lt;std::pair&lt;size_t, size_t&gt; &gt; pairs;&#10;    pairs.reserve(N);&#10;    std::unordered_set&lt;uint64_t&gt; seen;&#10;    auto key = [](size_t a, size_t b)-&gt; uint64_t {&#10;        if (a &gt; b) std::swap(a, b);&#10;        return (uint64_t(a) &lt;&lt; 32) | uint64_t(b);&#10;    };&#10;    for (size_t i = 0; i &lt; N; i++) {&#10;        size_t j = (i + 1 + (k % (N - 1))) % N;&#10;        if (dedupUnordered) {&#10;            uint64_t kk = key(i, j);&#10;            if (seen.count(kk)) continue;&#10;            seen.insert(kk);&#10;        }&#10;        pairs.emplace_back(i, j);&#10;    }&#10;    return pairs;&#10;}&#10;&#10;// -------------------- Comparative key hashing --------------------&#10;size_t Simulator::ComparativeKeyHash::operator()(const ComparativeKey &amp;k) const noexcept {&#10;    std::hash&lt;std::string&gt; hs;&#10;    size_t h = std::hash&lt;int&gt;()(k.winner) ^ std::hash&lt;int&gt;()(int(k.reason)) ^ std::hash&lt;size_t&gt;()(k.rounds);&#10;    for (auto &amp;line: k.finalMapDump) {&#10;        h ^= hs(line) + 0x9e3779b97f4a7c15ULL + (h &lt;&lt; 6) + (h &gt;&gt; 2);&#10;    }&#10;    return h;&#10;}&#10;&#10;bool Simulator::ComparativeKeyEq::operator()(const ComparativeKey &amp;a, const ComparativeKey &amp;b) const noexcept {&#10;    return a.winner == b.winner &amp;&amp; a.reason == b.reason &amp;&amp; a.rounds == b.rounds &amp;&amp; a.finalMapDump == b.finalMapDump;&#10;}&#10;&#10;// -------------------- Output formatting --------------------&#10;static std::string reasonToString(GameResult::Reason r) {&#10;    switch (r) {&#10;        case GameResult::ALL_TANKS_DEAD: return &quot;all tanks dead&quot;;&#10;        case GameResult::MAX_STEPS: return &quot;max steps&quot;;&#10;        case GameResult::ZERO_SHELLS: return &quot;zero shells&quot;;&#10;        default: return &quot;unknown&quot;;&#10;    }&#10;}&#10;&#10;static std::string resultMessage(int winner, GameResult::Reason reason) {&#10;    if (winner == 1) return &quot;Player 1 wins: &quot; + reasonToString(reason);&#10;    if (winner == 2) return &quot;Player 2 wins: &quot; + reasonToString(reason);&#10;    return &quot;Tie: &quot; + reasonToString(reason);&#10;}&#10;&#10;std::string Simulator::formatComparativeOutput(&#10;    const std::string &amp;gameMap,&#10;    const std::string &amp;alg1,&#10;    const std::string &amp;alg2,&#10;    const std::vector&lt;std::pair&lt;std::vector&lt;std::string&gt;, ComparativeKey&gt; &gt; &amp;grouped) {&#10;    std::ostringstream out;&#10;    out &lt;&lt; &quot;game_map=&quot; &lt;&lt; gameMap &lt;&lt; &quot;\n&quot;;&#10;    out &lt;&lt; &quot;algorithm1=&quot; &lt;&lt; alg1 &lt;&lt; &quot;\n&quot;;&#10;    out &lt;&lt; &quot;algorithm2=&quot; &lt;&lt; alg2 &lt;&lt; &quot;\n&quot;;&#10;    out &lt;&lt; &quot;\n&quot;;&#10;    bool firstGroup = true;&#10;    for (auto &amp;[gmNames, key]: grouped) {&#10;        if (!firstGroup) out &lt;&lt; &quot;\n&quot;;&#10;        firstGroup = false;&#10;        // 5th line: comma-separated GM names&#10;        for (size_t i = 0; i &lt; gmNames.size(); ++i) {&#10;            if (i) out &lt;&lt; &quot;, &quot;;&#10;            out &lt;&lt; gmNames[i];&#10;        }&#10;        out &lt;&lt; &quot;\n&quot;;&#10;        // 6th line: result message&#10;        out &lt;&lt; resultMessage(key.winner, key.reason) &lt;&lt; &quot;\n&quot;;&#10;        // 7th line: round number&#10;        out &lt;&lt; key.rounds &lt;&lt; &quot;\n&quot;;&#10;        // 8th line on: final map&#10;        for (auto &amp;line: key.finalMapDump) out &lt;&lt; line &lt;&lt; &quot;\n&quot;;&#10;    }&#10;    return out.str();&#10;}&#10;&#10;std::string Simulator::formatCompetitionOutput(&#10;    const std::string &amp;gameMapsFolder,&#10;    const std::string &amp;gameManagerSo,&#10;    const std::vector&lt;std::pair&lt;std::string, int&gt; &gt; &amp;scoresSorted) {&#10;    std::ostringstream out;&#10;    out &lt;&lt; &quot;game_maps_folder=&quot; &lt;&lt; gameMapsFolder &lt;&lt; &quot;\n&quot;;&#10;    out &lt;&lt; &quot;game_manager=&quot; &lt;&lt; gameManagerSo &lt;&lt; &quot;\n&quot;;&#10;    out &lt;&lt; &quot;\n&quot;;&#10;    for (auto &amp;[name, score]: scoresSorted) {&#10;        out &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; score &lt;&lt; &quot;\n&quot;;&#10;    }&#10;    return out.str();&#10;}&#10;&#10;// -------------------- Runners --------------------&#10;int Simulator::run(const Args &amp;args) {&#10;    try {&#10;        if (args.mode == Args::Mode::Comparative) return runComparative(args);&#10;        return runCompetition(args);&#10;    } catch (const std::exception &amp;e) {&#10;        std::cerr &lt;&lt; &quot;Fatal error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return 1;&#10;    }&#10;}&#10;&#10;int Simulator::runComparative(const Args &amp;args) {&#10;    // Prepare registrars&#10;    AlgorithmRegistrar::getAlgorithmRegistrar().clear();&#10;    GameManagerRegistrar::getGameManagerRegistrar().clear();&#10;&#10;    // Load algorithms&#10;    std::vector&lt;void *&gt; algHandles;&#10;    std::optional&lt;AlgWrap&gt; alg1 = loadAlgorithmSo(args.algorithm1File);&#10;    if (alg1) {&#10;        if (void *h = dlopenOrNull(args.algorithm1File)) algHandles.push_back(h);&#10;    }&#10;    std::optional&lt;AlgWrap&gt; alg2 = loadAlgorithmSo(args.algorithm2File);&#10;    if (alg2) {&#10;        if (void *h = dlopenOrNull(args.algorithm2File)) algHandles.push_back(h);&#10;    }&#10;    if (!alg1 || !alg2) {&#10;        std::cerr &lt;&lt; &quot;Error: failed to load algorithm(s).\n&quot; &lt;&lt; usageComparative();&#10;        dlcloseAll(algHandles);&#10;        return 1;&#10;    }&#10;&#10;    // Load game managers&#10;    auto [gms, gmHandles] = loadGameManagersFolder(args.gameManagersFolder, args.verbose);&#10;    if (gms.empty()) {&#10;        std::cerr &lt;&lt; &quot;Error: game_managers_folder has no valid .so game managers.\n&quot; &lt;&lt; usageComparative();&#10;        dlcloseAll(algHandles);&#10;        dlcloseAll(gmHandles);&#10;        return 1;&#10;    }&#10;&#10;    // Parse map using project InputParser (initializes Logger as needed)&#10;    Logger::getInstance().init(args.gameMapFile);&#10;    InputParser parser;&#10;    parser.parseInputFile(args.gameMapFile);&#10;    SatelliteView *mapView = parser.getSatelliteView();&#10;    if (!mapView) {&#10;        std::cerr &lt;&lt; &quot;Error: failed to parse game map: &quot; &lt;&lt; args.gameMapFile &lt;&lt; &quot;\n&quot; &lt;&lt; usageComparative();&#10;        dlcloseAll(algHandles);&#10;        dlcloseAll(gmHandles);&#10;        return 1;&#10;    }&#10;&#10;    const size_t width = parser.getWidth();&#10;    const size_t height = parser.getHeight();&#10;    const size_t maxSteps = parser.getMaxSteps();&#10;    const size_t numShells = parser.getNumShells();&#10;    const std::string mapName = parser.getBoardDescription();&#10;&#10;    struct OneRes {&#10;        std::string gmName;&#10;        ComparativeKey key;&#10;    };&#10;    std::mutex mtx;&#10;    std::vector&lt;OneRes&gt; results;&#10;&#10;    auto runOne = [&amp;](const GmWrap &amp;gw) {&#10;        auto gm = gw.makeGameManager();&#10;        if (!gm) return;&#10;&#10;        auto p1 = alg1-&gt;makePlayer(1, width, height, maxSteps, numShells);&#10;        auto p2 = alg2-&gt;makePlayer(2, width, height, maxSteps, numShells);&#10;        if (!p1 || !p2) return;&#10;&#10;        GameResult gr = gm-&gt;run(width, height, *mapView, mapName, maxSteps, numShells,&#10;                                *p1, alg1-&gt;name, *p2, alg2-&gt;name, alg1-&gt;tankFactory, alg2-&gt;tankFactory);&#10;&#10;        ComparativeKey key;&#10;        key.winner = gr.winner;&#10;        key.reason = gr.reason;&#10;        key.rounds = gr.rounds;&#10;&#10;        // Dump final game state&#10;        std::vector&lt;std::string&gt; dump;&#10;        dump.reserve(height);&#10;        SatelliteView *state = gr.gameState ? gr.gameState.get() : mapView;&#10;        for (size_t y = 0; y &lt; height; ++y) {&#10;            std::string row;&#10;            row.reserve(width);&#10;            for (size_t x = 0; x &lt; width; ++x) row.push_back(state-&gt;getObjectAt(x, y));&#10;            dump.push_back(std::move(row));&#10;        }&#10;        key.finalMapDump = std::move(dump);&#10;&#10;        std::lock_guard&lt;std::mutex&gt; lk(mtx);&#10;        results.push_back({gw.name, std::move(key)});&#10;    };&#10;&#10;    if (args.numThreads &lt;= 1) {&#10;        for (const auto &amp;gm: gms) runOne(gm);&#10;    } else {&#10;        ThreadPool pool(static_cast&lt;size_t&gt;(args.numThreads));&#10;        for (const auto &amp;gm: gms) pool.enqueue([&amp;, gm] { runOne(gm); });&#10;        pool.waitIdle();&#10;    }&#10;&#10;    if (results.empty()) {&#10;        std::cerr &lt;&lt; &quot;Error: no game managers produced results.\n&quot;;&#10;        dlcloseAll(algHandles);&#10;        dlcloseAll(gmHandles);&#10;        return 1;&#10;    }&#10;&#10;    // Group identical results&#10;    std::unordered_map&lt;ComparativeKey, std::vector&lt;std::string&gt;, ComparativeKeyHash, ComparativeKeyEq&gt; groups;&#10;    for (auto &amp;r: results) groups[r.key].push_back(r.gmName);&#10;&#10;    std::vector&lt;std::pair&lt;std::vector&lt;std::string&gt;, ComparativeKey&gt; &gt; grouped;&#10;    grouped.reserve(groups.size());&#10;    for (auto &amp;kv: groups) {&#10;        auto key = kv.first;&#10;        auto names = kv.second;&#10;        std::sort(names.begin(), names.end());&#10;        grouped.emplace_back(std::move(names), std::move(key));&#10;    }&#10;    std::sort(grouped.begin(), grouped.end(), [](const auto &amp;a, const auto &amp;b) {&#10;        return a.first.size() &gt; b.first.size();&#10;    });&#10;&#10;    // Emit output&#10;    const auto outPath = joinPath(args.gameManagersFolder, &quot;comparative_results_&quot; + epochTimeId() + &quot;.txt&quot;);&#10;    const auto content = formatComparativeOutput(args.gameMapFile, args.algorithm1File, args.algorithm2File,&#10;                                                 grouped);&#10;    std::string err;&#10;    if (!writeTextFile(outPath, content, err)) {&#10;        std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; err &lt;&lt; &quot;\n&quot;;&#10;        std::cout &lt;&lt; content;&#10;    }&#10;&#10;    dlcloseAll(algHandles);&#10;    dlcloseAll(gmHandles);&#10;    return 0;&#10;}&#10;&#10;int Simulator::runCompetition(const Args &amp;args) {&#10;    // Prepare registrars&#10;    AlgorithmRegistrar::getAlgorithmRegistrar().clear();&#10;    GameManagerRegistrar::getGameManagerRegistrar().clear();&#10;&#10;    // Load GM&#10;    auto gmOpt = loadGameManagerSo(args.gameManagerFile, args.verbose);&#10;    std::vector&lt;void *&gt; gmHandles;&#10;    if (!gmOpt) {&#10;        std::cerr &lt;&lt; &quot;Error: failed to load game_manager.\n&quot; &lt;&lt; usageCompetition();&#10;        dlcloseAll(gmHandles);&#10;        return 1;&#10;    }&#10;    if (void *h = dlopenOrNull(args.gameManagerFile)) gmHandles.push_back(h);&#10;&#10;    // Load algorithms&#10;    auto [algs, algHandles] = loadAlgorithmFolder(args.algorithmsFolder);&#10;    if (algs.size() &lt; 2) {&#10;        std::cerr &lt;&lt; &quot;Error: algorithms_folder has fewer than 2 valid .so files.\n&quot; &lt;&lt; usageCompetition();&#10;        dlcloseAll(algHandles);&#10;        dlcloseAll(gmHandles);&#10;        return 1;&#10;    }&#10;&#10;    // List maps&#10;    auto mapFiles = listRegularFiles(args.gameMapsFolder);&#10;    if (mapFiles.empty()) {&#10;        std::cerr &lt;&lt; &quot;Error: no map files in game_maps_folder.\n&quot; &lt;&lt; usageCompetition();&#10;        dlcloseAll(algHandles);&#10;        dlcloseAll(gmHandles);&#10;        return 1;&#10;    }&#10;&#10;    std::vector&lt;int&gt; scores(algs.size(), 0);&#10;    auto addWin = [&amp;](size_t idx) { scores[idx] += 3; };&#10;    auto addTie = [&amp;](size_t a, size_t b) {&#10;        scores[a] += 1;&#10;        scores[b] += 1;&#10;    };&#10;&#10;    std::mutex mtx;&#10;&#10;    auto runOne = [&amp;](const std::string &amp;mapPath, size_t ai, size_t aj) {&#10;        // Parse map&#10;        Logger::getInstance().init(mapPath);&#10;        InputParser parser;&#10;        parser.parseInputFile(mapPath);&#10;        SatelliteView *mapView = parser.getSatelliteView();&#10;        if (!mapView) return;&#10;&#10;        const size_t width = parser.getWidth();&#10;        const size_t height = parser.getHeight();&#10;        const size_t maxSteps = parser.getMaxSteps();&#10;        const size_t numShells = parser.getNumShells();&#10;        const std::string mapName = parser.getBoardDescription();&#10;&#10;        // Create GM instance&#10;        auto gm = gmOpt-&gt;makeGameManager();&#10;        if (!gm) return;&#10;&#10;        // Players&#10;        auto p1 = algs[ai].makePlayer(1, width, height, maxSteps, numShells);&#10;        auto p2 = algs[aj].makePlayer(2, width, height, maxSteps, numShells);&#10;        if (!p1 || !p2) return;&#10;&#10;        GameResult gr = gm-&gt;run(width, height, *mapView, mapName, maxSteps, numShells,&#10;                                *p1, algs[ai].name, *p2, algs[aj].name,&#10;                                algs[ai].tankFactory, algs[aj].tankFactory);&#10;&#10;        std::lock_guard&lt;std::mutex&gt; lk(mtx);&#10;        if (gr.winner == 1) addWin(ai);&#10;        else if (gr.winner == 2) addWin(aj);&#10;        else addTie(ai, aj);&#10;    };&#10;&#10;    bool usePool = args.numThreads &gt;= 2;&#10;    std::unique_ptr&lt;ThreadPool&gt; pool;&#10;    if (usePool) pool = std::make_unique&lt;ThreadPool&gt;(static_cast&lt;size_t&gt;(args.numThreads));&#10;&#10;    const size_t N = algs.size();&#10;    for (size_t k = 0; k &lt; mapFiles.size(); ++k) {&#10;        bool dedup = (N % 2 == 0) &amp;&amp; (k == (N / 2 - 1));&#10;        auto pairs = computePairsForK(N, k, dedup);&#10;        for (auto [i,j]: pairs) {&#10;            if (usePool) pool-&gt;enqueue([=] { runOne(mapFiles[k], i, j); });&#10;            else runOne(mapFiles[k], i, j);&#10;        }&#10;    }&#10;    if (usePool) pool-&gt;waitIdle();&#10;&#10;    // Build sorted scoreboard&#10;    std::vector&lt;std::pair&lt;std::string, int&gt; &gt; out;&#10;    out.reserve(algs.size());&#10;    for (size_t i = 0; i &lt; algs.size(); ++i) out.emplace_back(algs[i].name, scores[i]);&#10;    std::sort(out.begin(), out.end(), [](const auto &amp;a, const auto &amp;b) {&#10;        if (a.second != b.second) return a.second &gt; b.second;&#10;        return a.first &lt; b.first;&#10;    });&#10;&#10;    // Emit output&#10;    const auto content = formatCompetitionOutput(args.gameMapsFolder, args.gameManagerFile, out);&#10;    const auto outPath = joinPath(args.algorithmsFolder, &quot;competition_&quot; + epochTimeId() + &quot;.txt&quot;);&#10;    std::string err;&#10;    if (!writeTextFile(outPath, content, err)) {&#10;        std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; err &lt;&lt; &quot;\n&quot;;&#10;        std::cout &lt;&lt; content;&#10;    }&#10;&#10;    dlcloseAll(algHandles);&#10;    dlcloseAll(gmHandles);&#10;    return 0;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>