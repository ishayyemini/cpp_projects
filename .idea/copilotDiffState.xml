<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/hw_3/gameManager/GameLogger.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hw_3/gameManager/GameLogger.h" />
              <option name="originalContent" value="#ifndef LOGGER_H&#10;#define LOGGER_H&#10;&#10;#include &lt;fstream&gt;&#10;#include &lt;map&gt;&#10;#include &lt;string&gt;&#10;#include &lt;vector&gt;&#10;&#10;#include &quot;ActionRequest.h&quot;&#10;&#10;namespace GameManager_322868852_340849710 {&#10;    class GameLogger {&#10;    public:&#10;        GameLogger() : initialized(false) {&#10;        }&#10;&#10;        void logActions(std::vector&lt;std::tuple&lt;bool, ActionRequest, bool, bool&gt; &gt; actions);&#10;&#10;        void logResult(const std::string &amp;message);&#10;&#10;        bool init(const std::string &amp;map_name);&#10;&#10;        void close();&#10;&#10;        ~GameLogger() {&#10;            close();&#10;        }&#10;&#10;        // TODO rule of 5&#10;&#10;    private:&#10;        // File stream&#10;        std::ofstream out_file;&#10;&#10;        // Initialization status&#10;        bool initialized;&#10;    };&#10;&#10;&#10;    inline std::map&lt;ActionRequest, std::string&gt; action_strings = {&#10;        {ActionRequest::DoNothing, &quot;None&quot;},&#10;        {ActionRequest::MoveForward, &quot;Move Forward&quot;},&#10;        {ActionRequest::MoveBackward, &quot;Move Backward&quot;},&#10;        {ActionRequest::RotateLeft45, &quot;Rotate Left Eighth&quot;},&#10;        {ActionRequest::RotateRight45, &quot;Rotate Right Eighth&quot;},&#10;        {ActionRequest::RotateLeft90, &quot;Rotate Left Quarter&quot;},&#10;        {ActionRequest::RotateRight90, &quot;Rotate Right Quarter&quot;},&#10;        {ActionRequest::Shoot, &quot;Shoot&quot;},&#10;        {ActionRequest::GetBattleInfo, &quot;Get Battle Info&quot;},&#10;    };&#10;}&#10;&#10;#endif // LOGGER_H&#10;" />
              <option name="updatedContent" value="#ifndef LOGGER_H&#10;#define LOGGER_H&#10;&#10;#include &lt;fstream&gt;&#10;#include &lt;map&gt;&#10;#include &lt;string&gt;&#10;#include &lt;vector&gt;&#10;&#10;#include &quot;ActionRequest.h&quot;&#10;&#10;namespace GameManager_322868852_340849710 {&#10;    class GameLogger {&#10;    public:&#10;        GameLogger() : initialized(false) {&#10;        }&#10;&#10;        void logActions(std::vector&lt;std::tuple&lt;bool, ActionRequest, bool, bool&gt; &gt; actions);&#10;&#10;        void logResult(const std::string &amp;message);&#10;&#10;        bool init(const std::string &amp;map_name);&#10;&#10;        void close();&#10;&#10;        ~GameLogger() {&#10;            close();&#10;        }&#10;&#10;        // Copy constructor&#10;        GameLogger(const GameLogger&amp; other) : initialized(false) {&#10;            // Cannot copy file streams, so we don't copy the state&#10;            // User would need to call init() again on the copied object&#10;        }&#10;&#10;        // Copy assignment operator&#10;        GameLogger&amp; operator=(const GameLogger&amp; other) {&#10;            if (this != &amp;other) {&#10;                close(); // Close current file if open&#10;                initialized = false;&#10;                // Cannot copy file streams, so we don't copy the state&#10;                // User would need to call init() again on the assigned object&#10;            }&#10;            return *this;&#10;        }&#10;&#10;        // Move constructor&#10;        GameLogger(GameLogger&amp;&amp; other) noexcept : &#10;            out_file(std::move(other.out_file)), &#10;            initialized(other.initialized) {&#10;            other.initialized = false;&#10;        }&#10;&#10;        // Move assignment operator&#10;        GameLogger&amp; operator=(GameLogger&amp;&amp; other) noexcept {&#10;            if (this != &amp;other) {&#10;                close(); // Close current file if open&#10;                out_file = std::move(other.out_file);&#10;                initialized = other.initialized;&#10;                other.initialized = false;&#10;            }&#10;            return *this;&#10;        }&#10;&#10;    private:&#10;        // File stream&#10;        std::ofstream out_file;&#10;&#10;        // Initialization status&#10;        bool initialized;&#10;    };&#10;&#10;&#10;    inline std::map&lt;ActionRequest, std::string&gt; action_strings = {&#10;        {ActionRequest::DoNothing, &quot;None&quot;},&#10;        {ActionRequest::MoveForward, &quot;Move Forward&quot;},&#10;        {ActionRequest::MoveBackward, &quot;Move Backward&quot;},&#10;        {ActionRequest::RotateLeft45, &quot;Rotate Left Eighth&quot;},&#10;        {ActionRequest::RotateRight45, &quot;Rotate Right Eighth&quot;},&#10;        {ActionRequest::RotateLeft90, &quot;Rotate Left Quarter&quot;},&#10;        {ActionRequest::RotateRight90, &quot;Rotate Right Quarter&quot;},&#10;        {ActionRequest::Shoot, &quot;Shoot&quot;},&#10;        {ActionRequest::GetBattleInfo, &quot;Get Battle Info&quot;},&#10;    };&#10;}&#10;&#10;#endif // LOGGER_H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/hw_3/simulator/Simulator.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hw_3/simulator/Simulator.h" />
              <option name="originalContent" value="#ifndef TANKS_GAME_SIMULATOR_H&#10;#define TANKS_GAME_SIMULATOR_H&#10;&#10;#include &lt;functional&gt;&#10;#include &lt;memory&gt;&#10;#include &lt;optional&gt;&#10;#include &lt;string&gt;&#10;#include &lt;unordered_map&gt;&#10;#include &lt;unordered_set&gt;&#10;#include &lt;utility&gt;&#10;#include &lt;vector&gt;&#10;&#10;// Use the project's common API&#10;#include &quot;AbstractGameManager.h&quot;&#10;#include &quot;AlgorithmRegistrar.h&quot;&#10;#include &quot;GameManagerRegistrar.h&quot;&#10;#include &quot;InputParser.h&quot;&#10;#include &quot;Logger.h&quot;&#10;#include &quot;SatelliteView.h&quot;&#10;#include &quot;TankAlgorithm.h&quot;&#10;&#10;struct Args {&#10;    enum class Mode { Comparative, Competition };&#10;&#10;    Mode mode;&#10;&#10;    // comparative&#10;    std::string gameMapFile;&#10;    std::string gameManagersFolder;&#10;    std::string algorithm1File;&#10;    std::string algorithm2File;&#10;&#10;    // competition&#10;    std::string gameMapsFolder;&#10;    std::string gameManagerFile;&#10;    std::string algorithmsFolder;&#10;&#10;    // common&#10;    int numThreads = 1;&#10;    bool verbose = false;&#10;};&#10;&#10;class Simulator {&#10;public:&#10;    Simulator() = default;&#10;&#10;    int run(const Args &amp;args);&#10;&#10;    // CLI parsing and usage&#10;    static std::optional&lt;Args&gt; parseArgs(int argc, char **argv, std::string &amp;usageOrError);&#10;&#10;    static std::string usageComparative();&#10;&#10;    static std::string usageCompetition();&#10;&#10;    static std::optional&lt;Args&gt; handleUnknownArgs(const std::vector&lt;std::string&gt; &amp;unknown, std::string &amp;usageOrError);&#10;&#10;    static bool checkComparativeArgsErrors(const Args &amp;args, std::string &amp;usageOrError);&#10;&#10;    static bool checkCompetitionArgsErrors(const Args &amp;args, std::string &amp;usageOrError);&#10;&#10;    static bool checkModeErrors(const Args &amp;args, std::string &amp;usageOrError);&#10;&#10;    static std::optional&lt;Args::Mode&gt; sortArg(const std::string &amp;a, bool modeSet, Args &amp;args, std::string &amp;usageOrError,&#10;                                             std::vector&lt;std::string&gt; &amp;unknown,&#10;                                             const std::unordered_set&lt;std::string&gt; &amp;supported);&#10;&#10;private:&#10;    // Core runners&#10;    int runComparative(const Args &amp;args);&#10;&#10;    int runCompetition(const Args &amp;args);&#10;&#10;    // Filesystem helpers&#10;    static bool fileExistsReadable(const std::string &amp;path);&#10;&#10;    static bool dirExistsListable(const std::string &amp;path);&#10;&#10;    static std::vector&lt;std::string&gt; listRegularFiles(const std::string &amp;dir);&#10;&#10;    static std::vector&lt;std::string&gt; listFilesWithExtension(const std::string &amp;dir, const std::string &amp;ext);&#10;&#10;    static std::string joinPath(const std::string &amp;a, const std::string &amp;b);&#10;&#10;    // Dynamic load helpers&#10;    static void *dlopenOrNull(const std::string &amp;path);&#10;&#10;    // Registrar-based loading&#10;    struct AlgWrap {&#10;        void *dl;&#10;        bool has_dl;&#10;        std::string name;&#10;        PlayerFactory playerFactory;&#10;        TankAlgorithmFactory tankFactory;&#10;    };&#10;&#10;    static void closeAlgWrap(std::optional&lt;AlgWrap&gt; &amp;wrap);&#10;&#10;    static void closeAlgWrap(AlgWrap &amp;wrap);&#10;&#10;    static void closeAlgWrap(std::vector&lt;AlgWrap&gt; &amp;handles);&#10;&#10;    // Loads a single algorithm .so into AlgorithmRegistrar. Returns nullopt on failure.&#10;    static std::optional&lt;AlgWrap&gt; loadAlgorithmSo(const std::string &amp;soPath);&#10;&#10;    // Loads many algorithm .so files, returns loaded algorithms and their dls.&#10;    static std::vector&lt;Simulator::AlgWrap&gt; loadAlgorithmFolder(const std::string &amp;folder);&#10;&#10;    struct GmWrap {&#10;        void *dl;&#10;        bool has_dl = false;&#10;        std::string name;&#10;        GameManagerFactory makeGameManager;&#10;    };&#10;&#10;    static void closeGmWrap(std::optional&lt;GmWrap&gt; &amp;wrap);&#10;&#10;    static void closeGmWrap(GmWrap &amp;wrap);&#10;&#10;    static void closeGmWrap(std::vector&lt;GmWrap&gt; &amp;handles);&#10;&#10;    static void cleanComparative(std::optional&lt;AlgWrap&gt; &amp;alg1, std::optional&lt;AlgWrap&gt; &amp;alg2, std::vector&lt;GmWrap&gt; &amp;gms);&#10;&#10;    static int loadComparative(const Args &amp;args, std::optional&lt;AlgWrap&gt; &amp;alg1, std::optional&lt;AlgWrap&gt; &amp;alg2,&#10;                               std::vector&lt;GmWrap&gt; &amp;gms, std::unique_ptr&lt;SatelliteView&gt; &amp;mapView, size_t &amp;width,&#10;                               size_t &amp;height,&#10;                               size_t &amp;maxSteps,&#10;                               size_t &amp;numShells, std::string &amp;mapName);&#10;&#10;&#10;    static void cleanCompetition(std::optional&lt;GmWrap&gt; &amp;gmWrap, std::vector&lt;AlgWrap&gt; &amp;algs);&#10;&#10;    static int loadCompetition(const Args &amp;args, std::optional&lt;GmWrap&gt; &amp;gmWrap, std::vector&lt;AlgWrap&gt; &amp;algs,&#10;                               std::vector&lt;std::string&gt; &amp;mapFiles);&#10;&#10;    static void runOneCompetition(const Args &amp;args, std::optional&lt;GmWrap&gt; &amp;gmWrap, std::vector&lt;AlgWrap&gt; &amp;algs,&#10;                                  const std::string &amp;mapPath, size_t ai, size_t aj, std::mutex &amp;mtx,&#10;                                  std::vector&lt;int&gt; &amp;scores);&#10;&#10;    static void&#10;    buildSortedScoreboard(std::vector&lt;AlgWrap&gt; &amp;algs, std::vector&lt;int&gt; &amp;scores,&#10;                          std::vector&lt;std::pair&lt;std::string, int&gt; &gt; &amp;out);&#10;&#10;    // Loads a single game manager .so into GameManagerRegistrar. Returns nullopt on failure.&#10;    static std::optional&lt;GmWrap&gt; loadGameManagerSo(const std::string &amp;soPath);&#10;&#10;    // Loads many GMs from a folder&#10;    static std::vector&lt;GmWrap&gt; loadGameManagersFolder(&#10;        const std::string &amp;folder);&#10;&#10;    // Thread pool (created only when numThreads &gt;= 2; workers = numThreads; main waits)&#10;    class ThreadPool {&#10;    public:&#10;        explicit ThreadPool(size_t nThreads);&#10;&#10;        ~ThreadPool();&#10;&#10;        void enqueue(std::function&lt;void()&gt; task);&#10;&#10;        void waitIdle();&#10;&#10;        // TODO rule of 5&#10;&#10;    private:&#10;        struct Impl;&#10;        std::unique_ptr&lt;Impl&gt; impl_;&#10;    };&#10;&#10;    // Utilities&#10;    static std::string basenameNoExt(const std::string &amp;path);&#10;&#10;    static std::string epochTimeId();&#10;&#10;    static bool writeTextFile(const std::string &amp;path, const std::string &amp;content, std::string &amp;err);&#10;&#10;    // Comparative result key (group identical results)&#10;    struct ComparativeKey {&#10;        int winner; // 0 tie, 1,2&#10;        GameResult::Reason reason;&#10;        size_t rounds;&#10;        std::vector&lt;std::string&gt; finalMapDump; // lines of the final game state&#10;    };&#10;&#10;    struct ComparativeKeyHash {&#10;        size_t operator()(const ComparativeKey &amp;k) const noexcept;&#10;    };&#10;&#10;    struct ComparativeKeyEq {&#10;        bool operator()(const ComparativeKey &amp;a, const ComparativeKey &amp;b) const noexcept;&#10;    };&#10;&#10;    // Pairing for competition (dedup unordered pairs only for the even-N special case)&#10;    static std::vector&lt;std::pair&lt;size_t, size_t&gt; &gt; computePairsForK(size_t N, size_t k, bool dedupUnordered);&#10;&#10;    struct OneRes {&#10;        std::string gmName;&#10;        ComparativeKey key;&#10;    };&#10;&#10;    static void runOneComparative(const GmWrap &amp;gw, const Args &amp;args, const std::optional&lt;AlgWrap&gt; &amp;alg1,&#10;                                  const std::optional&lt;AlgWrap&gt; &amp;alg2, const std::unique_ptr&lt;SatelliteView&gt; &amp;mapView,&#10;                                  const size_t &amp;width, const size_t &amp;height, const size_t &amp;maxSteps,&#10;                                  const size_t &amp;numShells,&#10;                                  const std::string &amp;mapName, std::mutex &amp;mtx, std::vector&lt;OneRes&gt; &amp;results);&#10;&#10;    static std::vector&lt;std::pair&lt;std::vector&lt;std::string&gt;, ComparativeKey&gt; &gt; groupResComparative(&#10;        const std::vector&lt;OneRes&gt; &amp;results);&#10;&#10;    // Output&#10;    static std::string formatComparativeOutput(&#10;        const std::string &amp;gameMap,&#10;        const std::string &amp;alg1,&#10;        const std::string &amp;alg2,&#10;        const std::vector&lt;std::pair&lt;std::vector&lt;std::string&gt;, ComparativeKey&gt; &gt; &amp;grouped);&#10;&#10;    static std::string formatCompetitionOutput(&#10;        const std::string &amp;gameMapsFolder,&#10;        const std::string &amp;gameManagerSo,&#10;        const std::vector&lt;std::pair&lt;std::string, int&gt; &gt; &amp;scoresSorted);&#10;};&#10;&#10;#endif //TANKS_GAME_SIMULATOR_H&#10;" />
              <option name="updatedContent" value="#ifndef TANKS_GAME_SIMULATOR_H&#10;#define TANKS_GAME_SIMULATOR_H&#10;&#10;#include &lt;functional&gt;&#10;#include &lt;memory&gt;&#10;#include &lt;optional&gt;&#10;#include &lt;string&gt;&#10;#include &lt;unordered_map&gt;&#10;#include &lt;unordered_set&gt;&#10;#include &lt;utility&gt;&#10;#include &lt;vector&gt;&#10;&#10;// Use the project's common API&#10;#include &quot;AbstractGameManager.h&quot;&#10;#include &quot;AlgorithmRegistrar.h&quot;&#10;#include &quot;GameManagerRegistrar.h&quot;&#10;#include &quot;InputParser.h&quot;&#10;#include &quot;Logger.h&quot;&#10;#include &quot;SatelliteView.h&quot;&#10;#include &quot;TankAlgorithm.h&quot;&#10;&#10;struct Args {&#10;    enum class Mode { Comparative, Competition };&#10;&#10;    Mode mode;&#10;&#10;    // comparative&#10;    std::string gameMapFile;&#10;    std::string gameManagersFolder;&#10;    std::string algorithm1File;&#10;    std::string algorithm2File;&#10;&#10;    // competition&#10;    std::string gameMapsFolder;&#10;    std::string gameManagerFile;&#10;    std::string algorithmsFolder;&#10;&#10;    // common&#10;    int numThreads = 1;&#10;    bool verbose = false;&#10;};&#10;&#10;class Simulator {&#10;public:&#10;    Simulator() = default;&#10;&#10;    // Rule of 5&#10;    ~Simulator() = default;&#10;&#10;    Simulator(const Simulator&amp; other) = delete;&#10;    Simulator&amp; operator=(const Simulator&amp; other) = delete;&#10;&#10;    Simulator(Simulator&amp;&amp; other) noexcept = default;&#10;    Simulator&amp; operator=(Simulator&amp;&amp; other) noexcept = default;&#10;&#10;    int run(const Args &amp;args);&#10;&#10;    // CLI parsing and usage&#10;    static std::optional&lt;Args&gt; parseArgs(int argc, char **argv, std::string &amp;usageOrError);&#10;&#10;    static std::string usageComparative();&#10;&#10;    static std::string usageCompetition();&#10;&#10;    static std::optional&lt;Args&gt; handleUnknownArgs(const std::vector&lt;std::string&gt; &amp;unknown, std::string &amp;usageOrError);&#10;&#10;    static bool checkComparativeArgsErrors(const Args &amp;args, std::string &amp;usageOrError);&#10;&#10;    static bool checkCompetitionArgsErrors(const Args &amp;args, std::string &amp;usageOrError);&#10;&#10;    static bool checkModeErrors(const Args &amp;args, std::string &amp;usageOrError);&#10;&#10;    static std::optional&lt;Args::Mode&gt; sortArg(const std::string &amp;a, bool modeSet, Args &amp;args, std::string &amp;usageOrError,&#10;                                             std::vector&lt;std::string&gt; &amp;unknown,&#10;                                             const std::unordered_set&lt;std::string&gt; &amp;supported);&#10;&#10;private:&#10;    // Core runners&#10;    int runComparative(const Args &amp;args);&#10;&#10;    int runCompetition(const Args &amp;args);&#10;&#10;    // Filesystem helpers&#10;    static bool fileExistsReadable(const std::string &amp;path);&#10;&#10;    static bool dirExistsListable(const std::string &amp;path);&#10;&#10;    static std::vector&lt;std::string&gt; listRegularFiles(const std::string &amp;dir);&#10;&#10;    static std::vector&lt;std::string&gt; listFilesWithExtension(const std::string &amp;dir, const std::string &amp;ext);&#10;&#10;    static std::string joinPath(const std::string &amp;a, const std::string &amp;b);&#10;&#10;    // Dynamic load helpers&#10;    static void *dlopenOrNull(const std::string &amp;path);&#10;&#10;    // Registrar-based loading&#10;    struct AlgWrap {&#10;        void *dl;&#10;        bool has_dl;&#10;        std::string name;&#10;        PlayerFactory playerFactory;&#10;        TankAlgorithmFactory tankFactory;&#10;    };&#10;&#10;    static void closeAlgWrap(std::optional&lt;AlgWrap&gt; &amp;wrap);&#10;&#10;    static void closeAlgWrap(AlgWrap &amp;wrap);&#10;&#10;    static void closeAlgWrap(std::vector&lt;AlgWrap&gt; &amp;handles);&#10;&#10;    // Loads a single algorithm .so into AlgorithmRegistrar. Returns nullopt on failure.&#10;    static std::optional&lt;AlgWrap&gt; loadAlgorithmSo(const std::string &amp;soPath);&#10;&#10;    // Loads many algorithm .so files, returns loaded algorithms and their dls.&#10;    static std::vector&lt;Simulator::AlgWrap&gt; loadAlgorithmFolder(const std::string &amp;folder);&#10;&#10;    struct GmWrap {&#10;        void *dl;&#10;        bool has_dl = false;&#10;        std::string name;&#10;        GameManagerFactory makeGameManager;&#10;    };&#10;&#10;    static void closeGmWrap(std::optional&lt;GmWrap&gt; &amp;wrap);&#10;&#10;    static void closeGmWrap(GmWrap &amp;wrap);&#10;&#10;    static void closeGmWrap(std::vector&lt;GmWrap&gt; &amp;handles);&#10;&#10;    static void cleanComparative(std::optional&lt;AlgWrap&gt; &amp;alg1, std::optional&lt;AlgWrap&gt; &amp;alg2, std::vector&lt;GmWrap&gt; &amp;gms);&#10;&#10;    static int loadComparative(const Args &amp;args, std::optional&lt;AlgWrap&gt; &amp;alg1, std::optional&lt;AlgWrap&gt; &amp;alg2,&#10;                               std::vector&lt;GmWrap&gt; &amp;gms, std::unique_ptr&lt;SatelliteView&gt; &amp;mapView, size_t &amp;width,&#10;                               size_t &amp;height,&#10;                               size_t &amp;maxSteps,&#10;                               size_t &amp;numShells, std::string &amp;mapName);&#10;&#10;&#10;    static void cleanCompetition(std::optional&lt;GmWrap&gt; &amp;gmWrap, std::vector&lt;AlgWrap&gt; &amp;algs);&#10;&#10;    static int loadCompetition(const Args &amp;args, std::optional&lt;GmWrap&gt; &amp;gmWrap, std::vector&lt;AlgWrap&gt; &amp;algs,&#10;                               std::vector&lt;std::string&gt; &amp;mapFiles);&#10;&#10;    static void runOneCompetition(const Args &amp;args, std::optional&lt;GmWrap&gt; &amp;gmWrap, std::vector&lt;AlgWrap&gt; &amp;algs,&#10;                                  const std::string &amp;mapPath, size_t ai, size_t aj, std::mutex &amp;mtx,&#10;                                  std::vector&lt;int&gt; &amp;scores);&#10;&#10;    static void&#10;    buildSortedScoreboard(std::vector&lt;AlgWrap&gt; &amp;algs, std::vector&lt;int&gt; &amp;scores,&#10;                          std::vector&lt;std::pair&lt;std::string, int&gt; &gt; &amp;out);&#10;&#10;    // Loads a single game manager .so into GameManagerRegistrar. Returns nullopt on failure.&#10;    static std::optional&lt;GmWrap&gt; loadGameManagerSo(const std::string &amp;soPath);&#10;&#10;    // Loads many GMs from a folder&#10;    static std::vector&lt;GmWrap&gt; loadGameManagersFolder(&#10;        const std::string &amp;folder);&#10;&#10;    // Thread pool (created only when numThreads &gt;= 2; workers = numThreads; main waits)&#10;    class ThreadPool {&#10;    public:&#10;        explicit ThreadPool(size_t nThreads);&#10;&#10;        ~ThreadPool();&#10;&#10;        // Rule of 5&#10;        ThreadPool(const ThreadPool&amp; other) = delete;&#10;        ThreadPool&amp; operator=(const ThreadPool&amp; other) = delete;&#10;&#10;        ThreadPool(ThreadPool&amp;&amp; other) noexcept = default;&#10;        ThreadPool&amp; operator=(ThreadPool&amp;&amp; other) noexcept = default;&#10;&#10;        void enqueue(std::function&lt;void()&gt; task);&#10;&#10;        void waitIdle();&#10;&#10;    private:&#10;        struct Impl;&#10;        std::unique_ptr&lt;Impl&gt; impl_;&#10;    };&#10;&#10;    // Utilities&#10;    static std::string basenameNoExt(const std::string &amp;path);&#10;&#10;    static std::string epochTimeId();&#10;&#10;    static bool writeTextFile(const std::string &amp;path, const std::string &amp;content, std::string &amp;err);&#10;&#10;    // Comparative result key (group identical results)&#10;    struct ComparativeKey {&#10;        int winner; // 0 tie, 1,2&#10;        GameResult::Reason reason;&#10;        size_t rounds;&#10;        std::vector&lt;std::string&gt; finalMapDump; // lines of the final game state&#10;    };&#10;&#10;    struct ComparativeKeyHash {&#10;        size_t operator()(const ComparativeKey &amp;k) const noexcept;&#10;    };&#10;&#10;    struct ComparativeKeyEq {&#10;        bool operator()(const ComparativeKey &amp;a, const ComparativeKey &amp;b) const noexcept;&#10;    };&#10;&#10;    // Pairing for competition (dedup unordered pairs only for the even-N special case)&#10;    static std::vector&lt;std::pair&lt;size_t, size_t&gt; &gt; computePairsForK(size_t N, size_t k, bool dedupUnordered);&#10;&#10;    struct OneRes {&#10;        std::string gmName;&#10;        ComparativeKey key;&#10;    };&#10;&#10;    static void runOneComparative(const GmWrap &amp;gw, const Args &amp;args, const std::optional&lt;AlgWrap&gt; &amp;alg1,&#10;                                  const std::optional&lt;AlgWrap&gt; &amp;alg2, const std::unique_ptr&lt;SatelliteView&gt; &amp;mapView,&#10;                                  const size_t &amp;width, const size_t &amp;height, const size_t &amp;maxSteps,&#10;                                  const size_t &amp;numShells,&#10;                                  const std::string &amp;mapName, std::mutex &amp;mtx, std::vector&lt;OneRes&gt; &amp;results);&#10;&#10;    static std::vector&lt;std::pair&lt;std::vector&lt;std::string&gt;, ComparativeKey&gt; &gt; groupResComparative(&#10;        const std::vector&lt;OneRes&gt; &amp;results);&#10;&#10;    // Output&#10;    static std::string formatComparativeOutput(&#10;        const std::string &amp;gameMap,&#10;        const std::string &amp;alg1,&#10;        const std::string &amp;alg2,&#10;        const std::vector&lt;std::pair&lt;std::vector&lt;std::string&gt;, ComparativeKey&gt; &gt; &amp;grouped);&#10;&#10;    static std::string formatCompetitionOutput(&#10;        const std::string &amp;gameMapsFolder,&#10;        const std::string &amp;gameManagerSo,&#10;        const std::vector&lt;std::pair&lt;std::string, int&gt; &gt; &amp;scoresSorted);&#10;};&#10;&#10;#endif //TANKS_GAME_SIMULATOR_H&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>